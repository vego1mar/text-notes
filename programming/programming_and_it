/// punycode
// https://teamquest.pl/blog/2264_falszywa-strona-przegladarki-brave-instaluje-malware-z-pomoca-google
// https://teamquest.pl/img/static/blog/punycode.png
* xn--brav-yva[.]com → bravė.com
* xn--ldgr-xvaj.com → lędgėr.com
* xn--sgnal-m3a.com → sīgnal.com
* xn-- teleram-ncb.com → teleģram.com
* xn--brav-8va.com → bravę.com
%%

/// regular file
* How to recognize?
$ ls --classify
%%

/// door in Solaris
* What is it?
%%

/// game design basic issues
* keyboard inputs, using threads, bullets physics, text and audio using graphic engine, colision detection, NPCs, animations and textures
%%

/// Java - StringBuilder and StringBuffer
* Why C++ does not need it?
%%

/// Java - interface
* C++ equivalent: base classes
%%

/// generics vs templates
* Are those the same? No.
%%

/// C++ - char, signed char, unsigned char
* Why those are not treated uniformly?
%%

/// Go - routines
* and its equivalent in C++
%%

/// synchronous logger design issues
* goals: information storage mechanism, handling exceptions more easily
* Singleton version or not, then: thread-safeness
* severity levels, that should be in order to be comparable with operator<
* uniform content of the logged message
* consider techniques: RAII, copy/move semantics, exception handling, multithreading
* settings, e.g. log message formatting
* may be parameterized as Logger<T> for T=[std::string, stdout, <console>, std::ofstream, <database>]
* consider: use std::string or std::ostringstream?
* consider: do we want inserter operator<<, or chained expressions (through CRTP)?
* how to find points of potential data races?
* should Logger have switch to be enabled/disabled?
* should Logger have verbosity level?
* should we use queue + background task for flushing?
* should we recognize instances through ID or hash codes?
* consider: templatizing the Logger
* to use __LINE__ and __FILE__ or std::source_location?
* consider: inheritance or aggregation?
%%

/// asynchronous logger design issues
* lock-free queue or minimum blocking queue?
* handling signals to be able to flush at destructor
* should logging be in a single file or be splitted in multiple ones?
* what should be the naming convention of multiple logging files?
* one thread per file with conditional variable and mutex or one thread for all?
* consider: uptime and thread ID in uniform logger message
* consider: Active Object design pattern
* all I/O operations should be perform on a different thread
* consider: conditional logging with CHECK/ASSERT
* consider: both syntaxes of streams and printf functions
* consider: 'big' configuration file
* consider: turning on/off logging levels at runtime
* consider: Observer design pattern treated as one-to-many relationship, thus: Broker?
%%

/// Lippincott functions
* How to handle exceptions uniformly?
%%

/// bitmask type
// https://en.cppreference.com/w/cpp/named_req/BitmaskType
* usually: enum + operator| + operator&

namespace bitmask {
    enum FileReadOperation : long {
        SkipHeader     = 1L << 0,   // 2^0 = 1
        ParseAsText    = 1L << 1,   // 2^1 = 2
        IngnoreUnknown = 1L << 2,   // 2^2 = 4
        LimitToEndChar = 1L << 3,   // 2^3 = 8
        // ...
    }
    
    long operator|(const FileReadOperation& lhs, const FileReadOperation& rhs) const {
        return static_cast<long>(lhs) + static_cast<long>(rhs);
    }
    
    // bitwise operators: &, &=, |, |=, ^, ^=, ~ (AND, OR, XOR, NOT)
    
    // X |=  Y    →  sets the value Y in the object X
    // X &= ~Y    →  clears the value Y in the object X
    // X &   Y    →  nonzero result indicates that the value Y is set in the object X
};

int main() {
    using bm = namespace bitmask;
    const auto mask = bm::SkipHeader | bm::IgnoreUnknown;  // "0101"
}
%%

/// systemd and systemctl
* some useful commands
%%

/// I/O operation
* any operation that uses external storage
* internal storage: microprocessor memory and cache (register, L1, …), operation memory (RAM, ROM, …)
* external storage: mass storage devices (HDD, SDD, MC, flash, …), others (diskette, CD, DVD, …)
* I/O operations are considered to be slow
%%

/// copy constructor
* std::copy for C/C++ types
%%

/// move constructor
* std::move for C++ types
* std::exchange for C types
%%

/// C++ - some useful functions
* std::quoted
* std::copy, std::exchange
* std::begin, std::end, ...
%%

/// SQL database vs NoSQL database
// https://teamquest.pl/blog/2231_bazy-danych
* SQL databases: MySQL, Postgres, Oracle, MS SQL Server, Sybase
* SQL: relations between tables, vertical scaling, security, ACID with RDBMS
* NoSQL databases: MongoDB, Redis, Neo4j, Cassandra, Hbase
* NoSQL: distributed tables, horizontal scaling, performance, BASE
%%

/// ACID vs BASE
* ACID:
* atomicity (all operations are successful or none are)
* consistency (RDBMS forces state)
* isolation (transactions cannot violate integrity of data or other transactions)
* durability (finished transaction is considered to be a permanent change)

* BASE:
* Basically Available (no isolation, users may query database at any time)
* Soft State (consistency is not immediate, data may change in time)
* Eventually Consistent (at some point in time the consistency will be forced, data reads are allowed)
%%

/// vertical and horizontal scaling
# https://www.geeksforgeeks.org/overview-of-scaling-vertical-and-horizontal-scaling/
* assume simple architecture: Client (request) → Server, Client ← (respond) Server
* when the number of users increases, so thus the load of the server (it slows down)
* the solution: scale server capacity according to the increasing traffic

* vertical scaling (scale-up approach):
* single machine, more resources, single-point of failure
* when the server fails, then the downtime is high

* horizontal scaling (scale-out approach):
* adding more instances to the pool (more servers), not so easy to implement
* required: hardware (servers, routers), Load Balancer (requests routing)
%%

/// scalability
* a scalability is the abality of an IT system to adapt (to grow or to shrink) to hardware and software performance requirements
* in an essence: we want to software works equally good on any platform at any load
* quantification: concurrency, contention, coherency

* load scalability: constant system behaviour over more extensive load ranges
* spatial scalability: storage requirements do not increase unacceptably high as items grows
* time-spatial scalability: more objects does not significantly affect performance
* structural scalability: system does not significantly hinder objects increase
%%

/// software scalability vs hardware scalability
* software scalability: the number of users is incremented on a fixed hardware configuration
* hardware scalability: the number of physical processors is incremented in the hardware configuration while keeping the user load per processor fixed
%%

/// Linux/POSIX - pipe and FIFO files
# https://linux.die.net/man/2/pipe
* pipe is an undirectional data channel for IPC (interprocess communication)
* two file descriptors are referring to the ends of the pipe → pipefd[read_end, write_end]
* data written to the write end are buffered by the kernel until it is read from the read end
* on how to create, see 'man pipe' or 'man pipe2'
* on how to dump pipe input into a file, see 'man tee' or use '<command> | tee <file>'

* FIFO is a queue, that on Linux is called 'a named pipe'
* any process can open it for reading and writing, in the same way as an ordinary file
* it has to be open on both ends simultaneously before any I/O operations
* opening it for reading normally blocks it until other process opens it for writing
* on how to create, see 'man mknod', or 'man mkfifo', or 'man mkfifoat'
%%


/// POSIX
* Portable Operating System Interface for UNIX, IEEE 1003
* it standarizes: API, UI (awk, echo, ed, ...), system shell properties
* it has been implemented on OSes like: MacOS, QNX, GNU/Linux, FreeBSD
* on Windows use can use it through software: Cygwin, Interix, WSL, Windows C Runtime Library, etc.

* POSIX certified OSes: AIX, QNX Neutrino, Solaris, IRIX, HP-UX, INTEGRITY, EulerOS, UnixWare, Tru64
* mostly POSIX-compliant: Android, Darwin, FreeBSD, Linux, MINIX, Nucleos RTOS, VMware ESXi, Xenix
* IEEE documention is a high cost, hence 'Single UNIX Specification' standard has been published

* some standarized things:
* C library, command interpreter, utility programs
* processes, process triggers
* clocks and timers
* symbolic links (symlinks), pipes, queue with priorities, buses
* semaphors, memory locking interface, shared memory, message passing
* signal in the real time
* IPC, synchronous and asynchronous I/O operations
%%


/// Unix vs Linux
* What is the diferrence?
%%


/// multithreading - message passing vs shared state
* both are IPC techniques used for threads executions
* probably uses some sort of a MESI protocol (Invalide-based cache coherence protocol)

* message passing: uses an object model to distinguish the general function from the specific implementation
* it is a technique for invoking a program treated as behaviour
* the invoking program sends a message to a process, relies on it, then select and run some code
* the justification for this are: encapsulation, distribution
* typically used for processes that resides on remote machines
* the programmer just uses the message passing facilites mechanism
* system calls are used only to establish the shared memory space
* it is probably faster technique

* shared state: we are passing read-only data between different threads
* usually done through immutable data structures
* typically used for processes that are on the same computer, since it must share common address space
* the programmer must explictly write the synchronized code
* system calls are needed as kernel intervention for send/receive communication
* it is probably slower technique
%%


/// immutable vs mutable
%%

/// C2 - command and control server
%%

/// mainframe vs server
%%

/// HTML
* What kind of problem does it solve?
%%

/// C++ - tag dispatch
* std::false_type and std::true_type
%%

/// ISO/OSI model and TCP/IP model
// https://teamquest.pl/blog/2192_model-osi
* ISO/OSI is not used in practice, TCP/IP is
* TCP/IP model: 2-Ethernet → 3-IP → 4-Protocol (TCP, UDP, ICMP, ARP, …) → 7-Packet
* TCP/IP have no layers 5 (session) and 6 (presentation), there are only interpretations of it
%%


/// copy initialization
// https://devblogs.microsoft.com/oldnewthing/20210628-00/?p=105374
* the perils of initializing constructor (converting constructor)

class Buffer {
  public:
    Buffer(std::size_t capacity);                          // non-explicit ctor
    Buffer& operator=(Buffer const&) = delete;
    Buffer& operator=(Buffer&&) noexcept = delete;
};

Buffer b = 1;                                              // copy initialization
Buffer b = Buffer(1);                                      // does not create a temporary Buffer(1)
Buffer b = Buffer(Buffer(Buffer(1)));

extern Buffer get_buffer();
Buffer b = get_buffer();                                   // copy elision
%%


/// copy elision
%%

/// object marshalling
* serialization and deserialization
%%


/// synchronouos lock vs asynchronous lock
// https://devblogs.microsoft.com/oldnewthing/20210707-00/?p=105417

void MyObject::RunOne()
{
    std::lock_guard guard(m_mutex);
    
    if (!m_list.empty()) {
        auto& item = m_list.front();
        item.Run();
        item.Cleanup();
        m_list.pop_front();
    }
}

void MyObject::RunOneAsync()
{
    std::lock_guard guard(m_mutex);
    
    if (!m_list.empty()) {
        auto& item = m_list.front();
        co_await item.RunAsync();                          // re-entrant suspension point
        item.Cleanup();
        m_list.pop_front();
    }
}

IAsyncAction MyObject::RunOneAsync()
{
    std::optional<Item> item;
    
    {
        std::lock_guard guard(m_mutex);
        
        if (!m_list.empty()) {
            item.emplace(std::move(m_list.front()));
            m_list.pop_front();
        }
    }
    
    if (item) {
        co_await item->RunAsync();
        item->Cleanup();
    }
}
%%


/// 'lock-free' operations pattern
* capture the inputs
* perform some work
* atomically set the result

IAsyncAction MyObject::ReloadWidgetAsync() 
{
    // Capture the inputs
    Color color;
    
    {
        std::lock_guard guard(m_mutex);
        color = m_color;
    }
    
    // Perform some work
    auto widget = Widget();
    bool done = false;
    
    while (!done) {
        co_await widget.SetColorAsync(color);
        
        // Atomically set the results
        {
            std::lock_guard guard(m_mutex);
            
            if (color == m_color) {
                m_widget = widget;
                done = true;
                continue;
            }
            
            // Try again
            color = m_color;
        }
    }
}
%%


/// Wildcard in MS-DOS/Windows
// https://devblogs.microsoft.com/oldnewthing/20210713-00/?p=105433
* it is not search&replace, it is replace-assuming-the-same-length
* glob (*) here is treated as filler for (?)

ren FRED*.* WILMA*.*
// having "FRED123.TXT", expecting "WILMA123.TXT", results in "WILMA23.TXT"
%%


/// Keyboard layout
logical: QWERTY, QWERTZ, Dvorak, ...
physical: ANSI, ISO
%%


/// technological stack
a set of tools for implementing some intended IT idea; every external program that we need to build our own program, especially in terms of any framework that we must to deal with and know how to use it; programming languages, frameworks, libraries, developments tools, programming approaches
formally we perceving this twofold as front-end (client-side) and back-end (server-side)
in reference to a 'full stack developer' it may means both front-end and back-end knowledge; we may expect that this kind of developer knows how to build an application for the client as well as how to manage database server, and everything else thay may be needed to release the final product; designing, coding, debugging, deploying, servicing; in practice this may include technologies and terms such as: HTML5, CSS, Bootstrap, JavaScript, SaaS, DOM, Node.js, unit testing, Angular, React, vue.js, PHP, Java, Ruby, Python, C#, SQL, NoSQL, HTTP, REST API, MVC, microservices, AWS, Azure, Heroku, git
for a 'Python developer' requirement may include things like: deep understanding of the syntax, knowledge about standard library (random, json, datetime, os, re, logging, …), object-oriented programming (inheritance, polimorphism, composition, hermetization, abstract classes, …), testing (unit test framework, mocks, code coverage, …), types of data (int, string, tuple, list, set, dictionary), functional programming elements (generators, closures, …), decorators, context managers, language specific abilities (list/dict/set comprehension, Boolean algebra, …), exception handling, basic knowledge of SQL (SELECT, JOIN, INSERT, DELETE, UPDATE, …), must haves (git, Linux, concurrency vs asynchronicity), nice to haves (Docker, …)
mini-Google style: CentOS, HDFS, HBase, Hadoop, MapReduce, Job Tracker
%%


/// technological stack exemplar technologies
Backend: Java, C++, .NET/C#, Python, …
Frontend: Angular, React, Vaadin, …
Mobile native: Android (Java), iOS (Swift, Objective-C), …
Mobile cross-platform: Xamarin, Ionic, React Native, …
Mobile: Mobile View, Progressive Web Apss, …
Desktop native: .NET UWP, .NET WPF, …
Desktop cross-platform: JavaFX, Electron, …
Databases: MS SQL Server, MariaDB, Oracle, MongoDB, ElasticSearch, Flyway, …
Cloud systems: Amazon AWS, Azure, Docker, Ansible, Kubernetes, Serverless, …
Unit testing frameworks: NUnit (.NET), TestNG, Karma&Jasmine (Angular), Moq library, …
Automatic testing & quality frameworks: Selenium, Sonar, Jenkins, Postman, Cucumber, …
Real device testing & cross-browsers: fluentlenium, Appium Kali Linux with OWASP ZAP and OpenVAS, …
Test management, bug tracking, and reporting: Jira, Adaptavist, Redmine, …
Devops tools: Confluence, Bitbucket, Apache Kafka, Maven, RHAT, Tomcat, JBoss, Office365, Active Directory, VMware/Hyper-V, Zabbix, Nagios, Kibana, …
UX/UI design: Adobe Illustrator, Anima, Axure, …
%%


/// garbage in, garbage out
a term from data science
if you accept too much data of any sort, then it is most probable that you will produce a complicated mess
%%


/// Pop-up footnote in EPUB 3
<p>This is some text with a
    <a class="noteref" epub:type="noteref" href="#note">
        reference
    </a>
    word.
</p>

<aside class="footnote" epub:type="footnote" id="note">
    This is a corresponding note explaining the reference.
</aside>
%%


/// C++20: safe integer comparisons
int getValue1() { return -1; }
unsigned int getValue2() { return 1; }

int main() {
    // -1:  1111'1111 ; max_int 255
    //  1:  0000'0001 ; 1
    return getValue1() < getValue2();
}


#include <utility>
# cmp_equal | cmp_not_equal | cpm_less | cmp_greater | cmp_less_equal | cmp_greater_equal
template<class T, class U> constexpr bool cmp_equal(T t, U u) noexcept;
%%


/// xoroshiro: stably random PRNG
# XOR + shift + rotate
%%


/// digit separators and binary literals
auto v = 0b101110;
auto q = 0b1111'0000;
%%


/// std::as_const
#include <utility>
template<class T> constexpr std::add_const_t<T>& as_const(T& t) noexcept;
template<class T> void as_const(const T&&) = delete;
%%


/// statement myths: goto
# 'Goto Considered Harmful' by E. Dijkstra

# They cannot skip non-vacuous initialization
# They cannot jump in or out of functions
# They cannot be used in constexpr functions
# They cannot jump into try or catch statements
# They can be used to jump out of try or catch statements, just like continue and break
%%


/// myths: only one exit point per function
# Corrado Bohm, Giuseppe Jacopin: Flow Diagrams, Turing Machines and Languages with Only Two Formation Rules
# the idea: we can turn a diagram into a program (proofed by Bohm)

# it can increase source code complexity
# may involve constructing objects that are not necessary
# you should always think about the default object, even if this is not meaningful
# however, notice, that multiple returns still return to the same place in memory
%%


/// myths: data members should be all private
# not all types have invariants — consider Point(x,y,z) (encapsulation is used to enforce class invariants)
# public data members work well for classes that are: mutable, final, have no invariants.
%%


/// myths: initialize all variables on definition
float f {};                            # construction, not initialization
if (int n; cin >> n) f(n);             # n might be uninitialized

# sometimes it is wasteful
# define them when needed only (that way they don't stay uninitialized for long)
# encapsulate two-step initialization in a factory
%%


/// user-defined literals
MyType operator""_myType(unsigned long long int value) 
{
    // the user defined suffixes must start with an underscore
    // the user defined suffices are allowed to start with a capital letter
    // C++11
    return MyType{value};
}

int main() 
{
    // only 'unsigned long long int' can be used for integers
    // only 'long double' can be used for floating-points
    // only 'char' can be used for a single character
    // only 'const char*' and 'const char*, std::size_t size' can be used for strings
    42_myType
    
    // string literal (C++14) of type std::string
    using namespace std::literals::string_literals;
    auto myString = "hello"s;
    
    // chrono literals (C++14)
    using namespace std::literals::chrono_literals;
    auto threeSeconds = 3s;
    auto tenMinutes = 10min;

    // string_view literals (C++17) of type std::string_view
    using namespace std::literals::string_view_literals;
    auto myStringView = "hello"sv;
}
%%


/// STL: algorithms
# std::all_of
# std::any_of
# std::none_of

# std::find                                      # search for an element in the container
# std::find_if                                   # with an unary predicate
# std::find_if_not                               # returns the first mismatch
# std::find_end                                  # returns the last match
# std::find_first_of                             # returns an iterator
# std::search                                    # find_first
# std::search_n                                  # n matching occurrences of a value/predicate
# std::adjacent_find                             # returns 2 neighbouring items that are matching

# std::count                                     # iterator + item_to_search_for
# std::count_if                                  # with an unary predicate
# std::equal                                     # compare ranges; returns an integer
# std::mismatch                                  # not_equal; returns a pair of iterators
# std::is_permutation

# std::copy
# std::copy_n                                    # begin + end + number_of_items
# std::copy_if                                   # with an unary predicator
# std::copy_backward                             # does not reverse order of the elements

# std::move
# std::move_backward
# std::swap
# std::swap_ranges                               # begin1 + end1 + begin2
# std::iter_swap                                 # swaps iterators, not the content

# std::replace                                   # all occurrences
# std::replace_if                                # with an unary predicate
# std::replace_copy
# std::replace_copy_if

# std::fill                                      # assigns a value to each element
# std::fill_n                                    # begin_iterator + number_of_elements
# std::generate                                  # begin + end + generator
# std::generate_n                                # begin_iterator + number_of_items + generator

# std::remove                                    # shifts and item to the end of the original range
# std::remove_if                                 # with a unary predicate
# std::remove_copy
# std::remove_copy_if

# std::reverse                                   # reverse(reverse) == identity
# std::reverse_copy

# std::rotate                                    # pop(first) + push_back(first)
# std::rotate_copy                               # consecutive rotations != reverse order
# std::shift_left                                # C++20; move every element by 1 to the left
# std::shift_right                               # C++20

# std::unique                                    # removes duplicated (and consecutive) elements
# std::unique_copy

# std::random_shuffle                            # replaced by std::shuffle in C++17
# std::shuffle                                   # by deufalt it uses std::rand/std::srand
# std::sample                                    # C++17; returns a collection

# std::is_partitioned                            # is a range partitioned by a given predicate?
# std::partition                                 # partitioning: [attr1 attr1 attr2 attr3 …]
# std::partition_copy                            # does not work in place
# std::stable_partition                          # the relative order is kept
# std::partition_point                           # returns the dividing point between categories

# std::binary_search                             # UB if container is not sorted
# std::sort                                      # generic algorithm (heapsort/quicksort)
# std::is_sorted
# std::is_sorted_until
# std::equal_range                               # returns [std::lower_bound, std::upper_bound]
# std::lower_bound
# std::upper_bound

# std::merge                                     # merges ranges and returns an iterator to the last…
# std::inplace_merge                             # element; the elements will be sorted

# std::includes                                  # std::set
# std::set_difference
# std::set_intersection
# std::set_symmetric_difference
# std::set_union

# std::is_heap                                   # std::vector
# std::is_heap_until                             # std::deque
# std::make_heap
# std::push_heap
# std::pop_heap
# std::sort_heap

# std::max                                       # collections
# std::max_element
# std::min
# std::min_element
# std::minmax
# std::minmax_element
# std::clamp                                     # C++17; returns (value, lowest, highest); UB if hi<lo

# std::equal                                     # collections
# std::lexicographical_compare
# std::lexicographical_compare_three_way         # C++20; returns std::strong_ordering::less|equal|greater

# std::accumulate                                # replaces sum()
# std::reduce                                    # C++17; non-deterministic if not associative…
# std::transform_reduce                          # …or commutative

# std::cmp_equal                                 # safe integer comparisons
# std::cmp_not_equal                             # unsigned- and signed-wise
# std::cpm_less
# std::cmp_greater
# std::cmp_less_equal
# std::cmp_greater_equal

# std::as_const                                  # obtain const T from T
# std::reference_wrapper                         # store a ref as a pointer member in a class
# std::ref

# std::is_permutation                            # C++11; check ranges; UB if v1.size != v2.size
# std::next_permutation                          # lexicographically ordered; end == sorted
# std::prev_permutation                          # iterator at the end == sorted + reverted

# std::iota                                      # C++11; iterate-over-the-all and ++value
# std::inner_product
# std::partial_sum                               # accumulative summing up [a, a+b, a+b+c, …]
# std::adjacent_difference                       # accumulative subtracting [a, a-b, a-b-c, …]

# std::exclusive_scan                            # last element excluded from the partial sum
# std::inclusive_scan                            # std::partial_sum with execution policy
# std::transform                                 # unary + binary
# std::transform_exclusive_scan                  # std::exclusive_scan + lambda
# std::transform_inclusive_scan                  # constexpr

# std::uninitialized_copy                        # copies elements to uninitialized area
# std::uninitialized_copy_n
# std::uninitialized_fill                        # UB if out-of-range
# std::uninitialized_fill_n
# std::uninitialized_move
# std::uninitialized_move_n
# std::uninitialized_default_construct           # no zero-fill for trivial types!
# std::uninitialized_default_construct_n
# std::uninitialized_value_construct             # zero-fill for POD types
# std::uninitialized_value_construct_n
# std::destroy                                   # invoke the destructor for a range of objects
# std::destroy_n
# std::destroy_at
# std::construct_at                              # initialize an object with given parameters

# std::aligned_alloc                             # to use with alignas/alignof/sizeof
# std::free
# std::tie                                       # function bind
# std::get_temporary_buffer                      # allocates uninitialized contiguous storage
# std::return_temporary_buffer                   # deallocates the storage
# std::begin
# std::end
# std::size                                      # returns c.size() or typename N
# std::launder                                   # obtains a pointer at the given address

# std::memory_order                              # memory ordering around atomic operations
# std::quoted
# std::span                                      # a struct pair(pointer, pointee_size)
# std::byte                                      # a type that can hold '\0' as a regular element
# std::memcmp                                    # lexicographical memory compare

# std::midpoint                                  # an average (a+b)/2 without an overflow
# std::for_each
# std::to_string
# std::visit

# std::optional                                  # value? - either value or nullptr
# std::variant                                   # union replacement
# std::any                                       # void* replacement

# std::prev
# std::next                                      # iterator to the N-th element
# std::advance                                   # increment iterator by N
# std::distance                                  # number of hops; may be negative
# std::back_inserter

# std::apply                                     # invoke Callable with a tuple of args
# std::invoke                                    # invoke any Callable with given args
# std::invoke_result                             # deduces the result type of a Callable
# std::is_invocable

# std::mem_fn                                    # ptr-to-member → function object
# std::move_only_function                        # wraps a Callable
# std::function                                  # polymorphic function wrapper
# std::bind                                      # binds args to a function object
# std::bind_expression::_1                       # placeholder for the unbound argument

# assert                                         # runtime check
# static_assert                                  # compile-time check
#error                                           # displays message and stops compilation

# std::true_type                                 # constexpr std::integral_constant<bool, true>
# std::false_type                                # used to represent values true and false as types
# std::void_t
# std::is_detected
# std::conjunction                               # logical AND
# std::disjunction                               # logical OR
# std::negation                                  # logical NOT
# std::is_base_of
# std::is_base_class                             # accepts incomplete types
# std::conditional                               # <condition, if_true, if_false>
# std::enable_if                                 # conditionally removes func overload from resolution
# std::overload

# std::integer_sequence                          # integer_sequence<unsigned,1,2,3> → [1,2,3]
# std::index_sequence
# std::index_sequence_for                        # index_sequence_for<float,iostream,char>
# std::make_index_sequence                       # make_index_sequence<4> → [0,1,2,3]
# std::make_integer_sequence                     # make_integer_sequence<int,3> → [0,1,2]

# std::destroying_delete
# std::to_address                                # raw pointer to non-reference address
# std::type_info
# std::is_corresponding_member                   # the same declaration order, standard layout
# std::is_standard_layout
# std::is_layout_compatible
# std::is_member_object_pointer
# std::is_member_function_pointer
# std::is_member_pointer
# std::is_pointer
# std::is_array
# std::is_scalar                                 # arithmetic, pointer, ptr-to-member, enum, nullptr_t
# std::is_arithmetic                             # integral, floating-point
# std::is_integral                               # bool, *char*_t, short, int, long, long long
# std::is_floating_point                         # float, double, long double
# std::is_iec559                                 # IEEE 754; std::numeric_limits<T>::is_iec559
# std::is_enum
# std::is_scoped_enum

# std::copyable                                  # copy_constructible, movable, assignable_from<T&,_>
# std::movable                                   # is_object_v, move_constructible, swappable, ...
# std::regular                                   # semiregular, equality_comparable
# std::semiregular                               # copyable, default_initializable
# std::totally_ordered                           # boolean-testable: < > <= >=
# std::equality_comparable                       # boolean-testable: t==u, u==t, t!=u, u!=t

# std::copy_constructible                        # move_constructible<T>, constructible_from<T,_>
# std::move_constructible                        # constructible_from<T,T>, convertible_to<T,T>
# std::swappable                                 # requires(ranges::swap(a,b))
# std::swappable_with                            # requires + common_reference_with<T,U>
# std::assignable_from                           # is_lvalue_reference_v, common_reference_with
# std::is_lvalue_reference
# std::is_rvalue_reference                       # true_type/false_type
# std::is_reference

# std::sortable                                  # permutable, indirect_strict_weak_order
# std::permutable                                # it, indirectly_movable_storage, indirectly_swappable
# std::incrementable                             # regular, weakly_incrementable, requires(same_as)
# std::forward_iterator                          # it, derived_from<InputIt>, incrementable, sentinel_for
# std::input_iterator                            # input_or_output_iterator, indirectly_readable, ...
# std::indirectly_movable_storage                # movable, constructible_from, assignable_from, ...
# std::indirectly_swappable                      # indirectly_readable, requires(ranges::iter_swap)
# std::indirect_strict_weak_order                # indirectly_readable, copy_constructible, ...
# std::strict_weak_order                         # relation (irreflective and transitive)
# std::relation                                  # predicate(R,T,U) → [RTT, RUU, RTU, RUT] (binary)

# std::copy
# std::data                                      # returns c.data(), array, il.begin()
# std::swap
# std::exchange                                  # a MoveConstructible setter that returns the old value
# std::move                                      # a static_cast to an rvalue reference type
# std::forward                                   # std::move for templates parameters
# std::forward_as_tuple                          # wrap up a parameter pack into a single object
# std::piecewise_construct                       # marker: unpack params tuples and emplace(params(elem))

# std::deque                                     # double-ended queue (pipe)
# std::queue                                     # FIFO queue adaptor

# std::integral_constant                         # integer value, non-floating-point
# std::type_identity                             # typeid(type_identity<T>).name() == type_identity<T>
# std::to_underlying                             # enum { QL=42 }; → 42 or unsigned
# std::unreachable                               # invokes undefined behavior; consider case default
# std::ostream_joiner
# std::rank                                      # array dimension; rank<int[][][5]> == 3
# std::tuple_cat                                 # concatenation
# std::shift_left
# std::shift_right
# std::to_array                                  # flat C array to std::array
# std::in_place_t                                # construct in place, e.g. for std::optional
# std::format
%%


/// concepts
# In a technical manner we can say, that concepts are templates with constraints.
# A concept is supposed to be the interface between the generic library author, and the generic library user.

template <typename T> 
void test(T& encoder, std::span<std::byte> buffer) {
    auto state = encoder.init();
    encoder.encode(state, buffer);
}

// How to reflect in a concept that the result of init() is a type that can be later passed to encode()?

template <typename E> 
concept Encoder = requires(E& e, span<std::byte> b) {
    // concept requirements list
    e.encode(e.init(), b);
};

template <typename E> 
concept Encoder = requires(E& e, typename E::state_t& s, std::span<std::byte> b) {
    { e.init() } -> std::convertible_to<typename E::state_t>;
    e.encode(s, b);
};

// an alternative (requires is just an expression, thus we can conjugate it)
template <typename E> concept Encoder = requires(E& e) {
    typename E::state_t;
    { e.init() } -> std::convertible_to<typename E::state_t>;
}
&& requires(E& e, typename E::state_t& s, std::span<std::byte> b) {
    e.encode(s, b);
};

// another alternative with 'requires requires'
template <typename E> concept Encoder = requires(E& e) {
    typename E::state_t;
    { e.init() } -> std::convertible_to<typename E::state_t>;
 
    requires requires(typename E::state_t& s, std::span<std::byte> b) {
        e.encode(s, b);
    };
};

// an alternative with std::declval
template <typename E> concept Encoder = requires(E& e, std::span<std::byte> b) {
    typename E::state_t;
    { e.init() } -> std::convertible_to<typename E::state_t>;
    e.encode(std::declval<typename E::state_t&>(), b);
};


struct MyEncoder {
    using state_t = std::size_t;
    state_t init();
    void encode(state_t& s, std::span<std::byte> buf);
};

static_assert(Encoder<MyEncoder>)


# C++ Core Guidelines:
# T.10: Specify concepts for all template arguments
# T.11: Whenever possible use standard concepts.
# T.12: Prefer concept names over auto for local variables.
# T.13: Prefer the shorthand notation for simple, single-type argument concepts.
# T.20: Avoid 'concepts' without meaningful semantics.
# T.21: Require a complete set of operations for a concept.
# T.22: Specify axioms for concepts.
# T.23: Differentiate a refined concept from its more general case by adding new use patterns.
# T.24: Use tag classes or traits to differentiate concepts that differ only in semantics.
# T.25: Avoid complementary constraints.
# T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax.
# T.41: Require only essential properties in a template's concepts.

# Instead of 'typename T' use 'typename ConceptName'.
# Instead of unconstrained 'auto n = calculate()' use constrained 'Number auto n = calculate()'.
# Instead of 'template<typename T> requires Number<T>' use 'template<Number T>'.
# Axioms (statements that are taken to be true) are not supported by C++20, thus use comments for them.
# Instead of 'has_equal<T> && has_not_equal<T>' try '{a == b} && {a != b}' in requires body.
%%


/// SFINAE
# Substitution Failure Is Not An Error
%%


/// concepts: abbreviated function templates and constrained auto
template <typename T> void print(const std::vector<T>& vec) { }
void print2(const std::vector<auto>& vec) { }

auto func(auto param) { }
template <typename T> auto func(T param) { }

auto func(concept auto param) { }
template <typename T> requires concept<T> auto func(T param) { }
%%


/// concepts: requires clause/expression
# It's like SFINAE but in an easy-to-express syntax.

template<typename T>
concept has_string_data_member = requires(T v) { 
    { v.name_ } -> std::convertible_to<std::string>; 
};

template <typename T>
concept Clock = requires(T c) { 
    c.start();  
    c.stop();
    c.getTime();
};
%%


/// permissions: sticky bit
# T: not set for others
# -rwxr-x--T
# only the owner can make delete
%%


/// Singleton: Meyers' lazy initialized implementation
class Singleton {
  public:
    static Singleton& Instance() {
        static Singleton S;
        return S;
    }

private:
    Singleton();
    ~Singleton();
};


# Instead of the usual approach:
public class SingletonDemo {
    private static volatile SingletonDemo instance = null;

    private SingletonDemo() {}

    public static SingletonDemo getInstance() {
        if (instance == null) {
            synchronized (SingletonDemo.class) {
                if (instance == null) {
                    instance = new SingletonDemo();
                }
            }
        }
        return instance;
    }
}
%%


/// SplitMix64: hash instead of generating random numbers
# Usage case: game level generation (procedural generation).
# 1. It should be functionally randomized, so we need a random numbers.
# 2. We want it to be deterministic and repeatable (through seed; e.g. for testing, sharing world state).

/*
Algorithm 1:
1. Pluck random number to determine room size (m x m).
2. Pluck random number to determine number of enemies in room. 

Problem:
I want to change my algorithm from generating square rooms, to generating rectangle rooms. But I don't want to change the loot in my rooms. i.e, I want to change the algorithm to:

Algorithm 2:
1. Pluck random number to determine room width.
1.5. Pluck random number to determine room depth.
2. Pluck random number to determine loot in the room.  

If I just use seeded RNG, then the addition of step 1.5 will change the results of step 2 for a given seed. This might cause problems if my automated tests assume a certain loot item in a room. Or if people are sharing good or interesting seeds that depend on certain loot items.

Algorithm 3:
1. Hash number from (depth, room number, seed) to determine room size.
2. Hash number from (depth, room number, seed) to determine loot in room.

Algorithm 4:
1. Hash number from (depth, room number, seed, and the character 'w') to determine room width.
1.5. Hash number from (depth, room number, seed, and the character 'd') to determine room depth.
2. Hash number from (depth, room number, seed) to determine loot in room.

For a given seed, Algorithm 3 and Algorithm 4 will give the same output for step 2.  
*/


uint64_t gamma = 0x9e3779b97f4a7c15;             // StreamID
uint64_t state = 0xdeadbeef;                     // SplitMix64 Seed

uint64_t next()
{
    state = state + gamma;                       // update function
    
    uint64_t z = state;                          // mixing function/finalizer
    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
    z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
    z = z ^ (z >> 31);
    
    return z;
}


uint64_t at(uint64_t seed, uint64_t i, uint64_t gamma = 0x9e3779b97f4a7c15)
{
    uint64_t z = seed + i*gamma;                 // skip forward by i states
    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
    z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
    z = z ^ (z >> 31);    
    return z;    
}

bool has_gold_pile = hash(x, y, level_int, game_seed) % 100 < 10;
%%


/// functions: functions to call only once
class CostlyResult{};

class MyClass {
  public:
    [[nodiscard]] CostlyResult getCostly() && {
        return {};
    }
    
    [[nodiscard]] CostlyResult getThatCostly() {
        MyClass mc;
        return std::move(mc).getCostly();
    }
};

int main() {
    MyClass mc;
    auto r = std::move(mc).getCostly();
    auto t = mc.getThatCostly();
}
%%


/// design: giving a single object multiple COM identities (Windows)
# WinRT issue with COMs (Component Object Models)
# COM is a binary-interface standard used to IPC object creation (in: OLE, DirectX, .NET, …).
# The essence of COM is a language-neutral way of implementing objects that can be used in environments different from the one in which they were created, even across machine boundaries.

# We want to have a pattern for COM objects that will hand out references to themselves.
# 1/ make the callbacks separate objects that retain strong references to and forward to the main object
# 2/ the main object implement all of the necessary callbacks interfaces

template<typename Outer, auto Id>
struct CallbackWrapper {
    struct Wrapper : ICallback {
        HRESULT QueryInterface(REFIID riid, void** ppv)
        {
            if (riid == IID_IUnknown || riid == IID_ICallback) {
                *ppv = static_cast<ICallback*>(this);
                AddRef();
                return S_OK;
            }
            
            *ppv = nullptr;
            return E_NOINTERFACE;
        }

        ULONG AddRef() { return outer()->AddRef(); }
        ULONG Release() { return outer()->Release(); }
        HRESULT Invoke() noexcept { return outer()->OnInvoke<Id>(); }

      private:
        Outer* outer() 
        {
            return static_cast<Outer*>(reinterpret_cast<CallbackWrapper*>(this));
        }
    } callback;

    ICallback* GetCallback() { return &callback; }
};

template<typename Outer, auto... Ids>
struct CallbackWrappers : CallbackWrapper<Derived, Ids>... {
    template<auto Id>
    ICallback* GetCallback() {
        return static_cast<CallbackWrapper<Derived, Id>*>(this)->GetCallback();
    }

    template<auto Id>
    using CallbackWrapperOuter = CallbackWrapper<Outer, Id>;
    static_assert(((offsetof(CallbackWrapperOuter<Ids>, callback) == 0) && ...));
};

constexpr uint64_t callback_id(char const* s)
{
    // Untested implementation of FNV-1a
    uint64_t result = 0xcbf29ce484222325;
    
    for (size_t index = 0; s[index] != 0; index++) {
        result = (result ^ s[index]) * 1099511628211;
    }
    
    return result;
}

constexpr uint64_t operator"" _fnv1a(char const*s, size_t)
{
    return callback_id(s);
}

struct Widget final : IWidget 
  CallbackWrappers<Widget, "microphoneReady"_fnv1a, "dataAvailable"_fnv1a> {
    template<auto Id> HRESULT OnInvoke() = delete;
    template<> HRESULT OnInvoke<"microphoneReady"_fnv1a>();
    template<> HRESULT OnInvoke<"dataAvailable"_fnv1a>();

    void Initialize()
    {
        CallWhenMicrophoneReady(GetCallback<"microphoneReady"_fnv1a>());
        CallWhenDataAvailable(GetCallback<"dataAvailable"_fnv1a>());
    }
};
%%


/// windows: undocumented 'Rich' header
# http://bytepointer.com/articles/the_microsoft_rich_header.htm

# Exists in executables that utilized Microsoft Linker.
# It appers to be a part of the 16-bit DOS stub code (DWORD).
# The 'Rich' structure always appear at offset 0x80 and is encrypted.
# 'Rich' resides in PE header area, yet it is just a self-contained chunck of data.
%%


/// philosophy: SOLID principles
# A set of principles distilled from Robert C. Martin writings in the eraly 2000s.
# It was proposed as a way to think specifically about the quality of OO programming.
# Nowaday, we can say that they want to conform to the 'contract'.

# Single responsibility principle
# Original definition: “There should never be more than one reason for a class to change.”
# New definition: “Each module should do one thing and do it well.”
# e.g. this is to much: class Franken { playVideo(); renderGraphics(); buildKernel(); };

# Open-closed principle
# Original definition: “Software entities should be open for extension, but closed for modification.”
# New definition: “You should be able to use and add to a module without rewriting it.”
# e.g. extension through inheritance: class LoggingNotifier extends Notifier {};

# Liskov substitution principle
# Original definition: “If S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desirable properties of the program.”
# New definition: You should be able to substitute one thing for another if those things are declared to behave the same way.
# e.g. class Vehicle; class Bicycle extends Vehicle; f(Vehicle); b = new Bicycle(); f(b);

# Interface segregation principle
# Original Definition: “Many client-specific interfaces are better than one general-purpose interface.”
# New Definition: “Don’t show your clients more than they need to see”.
# e.g. interface PrintRequest { create(); delete(); }; class A implements PrintRequest, SomeImpl;

# Dependency inversion principle
# Original definition: “Depend upon abstractions, not concretions.”
# New definition: “Depend upon abstractions, not concretions.”
# e.g. interface Logger { write(); }; class FileLogger implements Logger; f(Logger l) { l.write(); };
%%


/// functions: how to prevent from accessing a lambda captured variables?
using hide_name = void(struct hidden_name);

winrt::fire_and_forget Refresh(winrt::com_ptr<Widget> const& widget) {
    auto copiedWidget = widget;
    hide_name widget;
    co_await winrt::resume_background();
    copiedWidget->Reset();
    copiedWidget->Reload();
}


void test(int);
int i;
hide_name a;

auto v = a;                  // error after use
i = a;                       // compiler error: wrong type/cannot convert
a = i;                       // compiler error: function as left operand/not assignable
test(a);                     // compiler error: invalid cast/no matching function call
i = a + 1;                   // compiler error: illegal/pointer to a function used in arithmetic
auto p = a + 1;              // compiler/linker error: ditto
auto size = sizeof(a);       // compiler error: illegal operand/invalid application of sizeof
a.method();                  // compiler error: request for member which is of non-class type
%%


/// C++20: constraining auto
std::floating_point auto compute_smth(std::floating_point a, std::floating_point b) {
    return a*b;
}

template<class T> 
concept not_pointer = !std::is_pointer_v<T>;

int* get_obj();

int main() {
    // it is not clear if returned value will be a float or a double:
    [[maybe_unused]] const std::floating_point auto p = compute_smth(1.3, 1.4f);
    // compile-time error:
    [[maybe_unused]] const not_pointer auto obj = get_obj();
}
%%


/// C: endless sine generation
static const double a = 2 * M_PI * 280 * 30e-6;
static const double dx = cos(a);
static const double dy = sin(a);
double x = 1, y = 0;                             // complex x + iy
int counter = 0;

void control_loop() {
    // angle sum trigonometric identities:
    // xx = cos((n+1)*a) = cos(n*a)*cos(a) - sin(n*a)*sin(a) = x*dx - y*dy
    // yy = sin((n+1)*a) = sin(n*a)*cos(a) + cos(n*a)*sin(a) = y*dx + x*dy
    double xx = dx*x - dy*y;
    double yy = dx*y + dy*x;
    x = xx, y = yy;

    // renormalize once in a while, based on:
    // https://www.gamedev.net/forums/topic.asp?topic_id=278849
    // straightforward normalization: double d = 1/sqrt(x*x + y*y); x *= d, y *= d;
    // using Taylor approximation expansion we may avoid the reciprocal: d = 1 - (x*x + y*y - 1)/2
    if ((counter++ & 0xff) == 0) {
        double d = 1 - (x*x + y*y - 1)/2;
        x *= d, y *= d;
    }

    double sine = y;
}
%%


/// std::string_view: pass by value
# (1) eliminate a pointer indirection in the callee
# (2) eliminate a spill in the caller
# (3) eliminate aliasing

int by_value(std::string_view sv) { 
    // register-to-register move
    return sv.size(); 
}
int by_ref(const std::string_view& sv) { 
    // ref passed in register 
    // + a memory load in order to extract the member function
    return sv.size(); 
}

call_by_value(std::string_view sv) { 
    // in-register variable set, then jump to function instructions
    by_value("hello"); 
}
void call_by_ref(std::string_view sv) { 
    // in-register variable set, make space on the stack for the address, then jump
    // and clean up that space at function end
    by_ref("hello"); 
}

void work_by_value(std::string_view sv, size_t *p) {
    // compiler will probably optimize this to:
    // *p = sv.size();
    *p = 0;
    for (size_t i=0; i<sv.size(); ++i) *p += 1;
}
void work_by_ref(const std::string_view& sv, size_t *p) {
    // compiler cannot optimize this; consider incrementation of *size_p:
    // std::string_view sv = "hello";
    // size_t *size_p = &sv.__size_;
    // work_by_ref(sv, size_p);
    *p = 0;
    for (size_t i=0; i<sv.size(); ++i) *p += 1;
}
%%


/// iterators fold: iterate backwards
template<class.. Ts> void print_args_backwards(Ts... ts) {
    auto print_one = [](auto t) {
        std::cout << t << std::endl;
        return std::type_identity<void>{};
    };
    
    std::cout << "*** Backwards ***" << std::endl;
    (print_one(ts) = ...);
    std::cout << "*** Forwards ***" << std::endl;
    (print_one(ts), = ...);
}

int main() {
    print_args_backwards(1, 2, "hello", 3, 4, "world");
}
%%


/// containers: heterogenous access for searching inside associative containers
# The idea is to search with things different from the 'key type' but comparable to it.
# By this, we can avoid the cost of creating a temporary key object.
# It is supported since C++14, but in C++20 we got it for unordered collections.

// template<class Key, 
//          class T,
//          class Compare = std::less<Key>,
//          class Allocator = std::allocator<std::pair<const Key, T>>
// > class map;
std::map<std::string, int, std::less<>> trIntMap {
    { "Hello Super Long String", 1 },
    { "Another Longish String", 2 },
    { "This cannot fall into SSO buffer", 3 },
};
std::cout << "Lookup in trIntMap by const char*: \n";
std::cout << trIntMap.contains("Hello Super Long String") << '\n';


struct string_hash {
    using is_transparent = void;
    
    [[nodiscard]] size_t operator()(const char *txt) const {
        return std::hash<std::string_view>{}(txt);
    }
    
    [[nodiscard]] size_t operator()(std::string_view txt) const {
        return std::hash<std::string_view>{}(txt);
    }
    
    [[nodiscard]] size_t operator()(const std::string &txt) const {
        return std::hash<std::string_view>{}(txt);
    }
};
std::unordered_map<std::string, int, string_hash, std::equal_to<>> intMapTransparent {
    { "Hello Super Long String", 1 },
    { "Another Longish String", 2 },
    { "This cannot fall into SSO buffer", 3 },
};
bool found = intMapNormal.contains("Hello Super Long String");
std::cout << "Found: " << std::boolalpha << found << '\n';
%%


/// code quality: Code Lifecycle maintenance
# by Phil Nash, "career"

# correctness
# applicability
# reliability
# evolvability
# efficiency
# reasonability
%%


/// load and store architecture
# LSU — load-store unit
# memory for instructions, responsible for generating virtual addresses, loading data from memory or storing it back to memory from registers
# load/store: std::memory_order_relaxed/std::memory_order_seq_cst
%%


/// code quality: quality attributes for software systems
# Some important quality attributes for software systems
Availability | Can I use the system when and where I need to?
Conformance to standards | Does the system comply with all applicable standards for functionality, safety, communication, certification, and interfaces?
Efficiency | Does the system use computer resources economically?
Installability | Can I easily install, uninstall, and reinstall the system and upgrades?
Integrity | Does the system protect against data inaccuracy, corruption, and loss?
Interoperability | Does the system connect well with others to exchange data and services?
Maintainability | Can developers easily modify, correct, and enhance the system?
Performance | Does the system respond sufficiently quickly to user actions and external events?
Portability | Can the system be migrated to different platforms easily?
Reliability | Does the system run when it’s supposed to without failing?
Reusability | Can developers reuse portions of the system in other products?
Robustness | Does the system respond sensibly to erroneous inputs and unexpected operating conditions?
Safety | Does the system protect users from harm and property from damage?
Scalability | Can the system easily expand to accommodate more users, data, or transactions?
Security | Does the system protect against malware attacks, intruders, unauthorized users, and data theft?
Usability | Can users easily learn how to use the system to accomplish their tasks?
Verifiability | Can testers determine whether the software was implemented correctly?

# Some additional quality attributes for physical products containing embedded software
Durability | Will the product hold up well under normal usage conditions?
Extensibility | Can new functionality, sensors, or other hardware be added easily to the product without disrupting its functioning?
Fault handling | Does the product detect, recover from, and log faults that occur?
Manufacturability | Is the product easy and cost-effective to manufacture?
Resource usage | Does the product retain enough slack capacity in the resources consumed for memory, network bandwidth, power, processor capacity, and so forth?
Serviceability | Can people efficiently perform preventive and corrective maintenance on the product?
Sustainability | Does the product have minimum adverse environmental impacts over its lifecycle, from extraction of raw materials to manufacturing, usage, and disposal?
Upgradability | Can the product easily be enhanced by adding or replacing components?
%%


/// c++ 20: designated initializers
Designated Initialization is a form of Aggregate Initialization.

An Aggregate type:
* is an array type or,
* is a class type that:
* has no private or protected direct non-static data members
* has no user-declared or inherited constructors
* has no virtual, private, or protected base classes
* has no virtual member functions


struct Point { double x { 0.0 }; double y { 0.0 }; };
const Point p { .x = 10.0, .y = 20.0 };
const Point offset { .x { 100.0 }, .y { -100.0 } };
const Point translation { .x = 50.0, .y { -40.0 } };

struct Date { int year; int month; int day; };
Date inFuture { .year = 2050, .month = 4, .day = 10 };


The following rules apply to designated initializers:
* Designated initializers work only for aggregate initialization
* Designators can only refer to non-static data members.
* Designators in the initialization expression must have the same order of data members in a class declaration.
* Not all data members must be specified in the expression.
* You cannot mix regular initialization with designaters.
* There can be only one designator for a data member.
* You cannot nest designators

struct Date {
    int year;
    int month;
    int day;
    MinAndHour mh;
    static int mode;
};
Date d1 { .mode = 10; }                // err, mode is static!
Date d2 { .day = 1, .year = 2010 };    // err, out of order!
Date d3 { 2050, .month = 12 };         // err, mix!
Date d4 { .mh.min = 55 };              // err, nested!
%%


/// virtualization: virtual machines insight
virtual machine: a software that emulates all the functionalities of a physical machine and runs on top of a host operating system or a hypervisor
hypervisor: a system software that acts as an intermediary between computer hardware and virtual machines
hypervisor modules: dispatcher (reroutes the instructions), allocator (for machine resources), interpreter
hypervisor types: native (direct access to CPU, e.g. MS Hyper-V), OS-based (many machines on a single host, e.g. VirtualBox)
VM states: live (real-time change), persistent (configuration files, snapshots)

CPU virtualization: hardware split
memory virtualization: hardware split/sharing
network virtualizaton: V-NIC (virtual switch), P-NIC for uplinks (physical router out of the VM handles tracing between machines in VLAN, MAC table lookup; outgoing traffic is fetched by the hypervisor)
storage virtualization: virtual SCSI controller (disk read/write produces SCSI command that arrive at the hypervisor; if it's VMDK or similar then it goes to a local storage; for network storage iSCSI is used)

benefits: 
* consolidation (efficiency through workload elasticity)
* efficiency (load balancing through hypervisor)
* mobility (physical adapters can be easily changed; managing hardware resources through different machines without significant downtimes; decoupling - no fixed relationship between VM and specific hardware; consider live migration through a kernel port - memory bitmap configuration copy to migrate to other VM)
* automated load balancing (automatic load bouncing - automatic live migrations)
%%


/// design: designing classes guidelines (Klaus Iglberger, CppCon 2021)
# Design classes for easy change
# Design classes for easy extension

# Design for readability: spent time to find good names for all entities
// empty() — action or is_empty() — query ?

# Resist the urge to put everything into one class. Separate concerns!
template<class T, class Allocator = std::allocator<T>> class vector;
template<class ForwardIt> constexpr void destroy(ForwardIt first, ForwardIt last);

# If you use OO programming, use it properly.
// Inheritance is rarely the answer. Delegate to services: has-a trumps is-a.
// Separate concerns to isolate and simplify change (SRP - Separation of Concerns/Single-Responsibility Principle, high cohesion/low coupling, orthogonality).
// Open-Closed Principle: prefer design that simplifies the extension by types or operations
// DRY principle: reduce duplication in order to simplify change
// Design patterns: named, carries an intent, aims at reducing dependencies, provide abstraction, has proven to work
// Strategy pattern provides a dependency injection for Shape-Circle-Square problem. Either way, template parameter is preferred.

# Don't guess! If you expect change, prefer design that makes this change easy. If you don't expect any change, learn from the next change.

class IPersistence {                                       // NVI — Non-Virtual Interface idiom
  public:                                                  // simplify change (SRP)
    IPersistence();                                        // changes has no impact on callers
    virtual ~IPersistence();                               // reduced duplication (DRY)
    bool write(const Blob& blob);
  private:
    virtual bool prepareWrite() = 0;
    virtual bool doWrite(const Blob& blob) = 0;
};

# Classes should be: concise and focused on one purpose (SRP), developed with extensibility in mind (OCP), split into smaller pieces to favor reuse (DRY).

# Design for testability.
# How to test private members? Separate concerns: move the member into a private namespace, or into another class as a separate service.
# Another possibility to consider: make the test a friend.


# Core Guidelines C.20: If you can avoid defining default operations, do The Rule of 0.
# C.23: If a class has a raw pointer (T*) or reference (T&), consider whether it might be owning.
# C.33: If a class has an owning pointer member, define a destructor.
# R.3: A raw pointer (a T*) is non-owning.
# R.1: Manage resources automatically using resource handles and RAII (Resource Aquisition is Initialization).
# Strive for the Rule of 0: classes that don't require an explicit destructor, explicit copy operations and explicit move operations are much easier to handle.
# C.21: If you define or =delete any default operation, define or =delete them all (The Rule of 5).
# C.20: If you can avoid defining default operations, do The Rule of 0.
# Strive for the Rule 0, but if it cannot be achieved (e.g. because the class implements RAII itself), follow the Rule of 0.


# Prefer to create default objects by means of an empty set of braces (value initialization).
# Avoid writing an empty default constructor.
# C.47: Define and initialise member variables in the order of member declaration.
# C.49: Prefer initialization to assignment in constructors.
# C.51: Use delegating constructors to represent common actions for all constructors of a class.
# C.44: Prefer default constructors to be simple and non-throwing.
# C.48: Prefer in-class initializers to member initializers in constructors for constant initializers.
# Prefer initialize pointer members to nullptr with in-class member initializers.
struct Widget {
    int i;                   // note: assignment is not an initialization
    std::string s;           // std::string s{"in-class initializer"};
    int* pi;
};
int main() 
{
    Widget w1;               // default initialization: i, pi uninitialized, s default-constructed
    Widget w2{};             // value initialization: i=0, pi=nullptr, s default-constructed
                             // if there is no user-defined ctor, w2 is zeroed
};

# C.46: By default, declare single-argument constructors explicit.
class Widget {
  public:
    Widget() = default;
    explicit Widget(int j) : i{j} {              // delegating constructor
        // proper object lifetime starts         // explicit prohibits implicit conversion from int
    }
  private:
    int i{42};                                   // in-class initializers:
    std::string s{"cppcon"};
    int* pi{};                                   // nullptr
};

# Consider the alignment of the data members when adding member data to a struct or class.
# C.47: Define and initialise member variables in the order of member declaration.
struct Widget1 {             // sizeof(Widget1) → 24
    bool b1;                 // char padding1[7];
    double d;                // needs to be 8-byte aligned on x64
    bool b2;                 // char padding2[7];
};

struct Widget2 {             // sizeof(Widget2) → 16
    double d;                // largest first, 8 B
    bool b1;                 // 2 B
    bool b2;                 // char padding[6];
};

struct Widget3 {             // sizeof(Widget3) → 32
    std::string s;           // assumption: 24 B (3 pointers)
    bool b1;                 // 2 B
    bool b2;                 // char padding[6];
                             // alignment decides about the padding of the data members
};

# Con.2: By default, make member functions const.
# Const correctness is part of the semantics of your class.
# Encapsulate design decisions (i.e. variation points).
template<typename Type, size_t Capacity>
class FixedVector final {
  public:
    using iterator = Type*;                                // encapsulate design decisions:
    using const_iterator = const Type*;                    // no one has to know about the…
    iterator begin() const noexcept;                       // …internal types
    const_iterator cend() const noexcept;
};

namespace std {
    template<typename T, typename Allocator = std::allocator<T>>
    class vector {
      public:
        constexpr T* data() noexcept;                      // opposite example:
        constexpr T const* data() const noexcept;          // a raw pointer is expected here
    };
}

# C.12: Don't make data members const or references.
# Remember that a class with a const or reference data member cannot be copy/move assigned by default.
# Strive for symmetry between the two copy/move operations.
struct Widget {
  public:
    Widget(double& d) : d_(d) {}
    double& get() noexcept { return d_; }
    double const& get() const noexcept { return d_; }
  private:                                                 // ref members can be stored as pointers
    std::reference_wrapper<double> d_;                     // double* d_;
};


class Widget {                         // every method is visible
  public:                              // access specifier
    void doSomething(int);
  private:                             // function call resolution:
    void doSomething(double);          // name lookup → overload → access labels → =delete
};
Widget w;                              // accessibility != visibility
w.doSomething(1.0);                    // access violation, compilation error
%%


/// basics: concurrency (Mike Shah, CppCon 2021)
std::thread                  // often defined as a 'lightweight process'
std::jthread                 // launches a thread and joins it immediately

# pitfalls: data races, starvation, and deadlock (acquiring a lock but not releasing it)
std::mutex                   // mutual exclusion - a global lock to deal with data races
std::lock_guard              // RAII-compliant; use it instead of lock/unlock
std::scoped_lock             // can acquire multiple mutexes locks at once
std::atomic                  // for a single value synchronizations
std::call_once               // for static local variables (no lock needed)
std::condition_variable      // a way to signal an event between 2+ threads with wait/notify
std::unique_lock             // RAII-compliant facility for std::condition_variable

# asynchronous programming: execution can happen independently of the main program flow
# asynchronous: 'without synchronicity', 'without order'
std::async                   // promise and futures (wait for the result if it is needed)
                             // std::async(std::launch::async, std::function);
                             // use case: NIO — Non-Blocking Input/Output

# tools: thread sanitizers (concurrency violations detectors)
# issues: performance (100 threads doesn not make app 100x faster), false sharing, thread pool, …
# C++20 feature: coroutines, memory model (defines the order of read/write to memory)
# parallel algorithms: std::par, std::par_unseq

# concurrency patterns: 
// Readers-Writers Problem      std::shared_mutex with std::unique_lock (multiple acquisition)
// Producer-Consumer            usually based on std::deque
// Barrier                      std::counting_semaphore, std::latch, std::barrier
%%


/// an average (a+b)/2 without an overflow
unsigned average(unsigned a, unsigned b) {
    return a + (b - a)/2;                                  // a < b; considered non-portable
}

unsigned average(unsigned a, unsigned b) {
    return (a/2) + (b/2) + (a & b & 1);                    // US patent US6007232A (2016)
}

unsigned average(unsigned a, unsigned b) {
    return (a & b) + (a ^ b) / 2;                          // SWAR — SIMD within a register
}

unsigned average(unsigned a, unsigned b) {
    return std::midpoint(a, b);                            // C++20; rounded towards a
}

# better solutions require intrinsic instructions (add-two-values-and-report-the-result-as-well-as-carry, rotate-right-through-carry) which are platform dependent
%%


/// winrt: COM aggregation
{   // doesn't work for tear-offs
    if (SUCCEEDED(m_inner->QueryInterface(IID_PPV_ARGS(&m_cachedInner)))) {
        this->Release();
    }
    
    this->AddRef();
    m_cachedInner->Release();

    if (SUCCEEDED(m_outer->QueryInterface(IID_PPV_ARGS(&m_cachedOuter)))) {
        // the outer object formally goes by the name 'controlling unknown'
        // QueryInterface(IUnknown)
        m_outer->Release();
    }

    m_outer->AddRef();
    m_cachedOuter->Release();
}

# For tear-offs: for each aggregated COM do: forward reference count operations to the outer object
%%


/// constexpr/consteval: is_constant_evaluated
# if (std::is_constant_evaluated()) {}
# if constexpr (conditional) {}
# if consteval {}


#include <type_traits>

consteval int get_value(int i)                   // immediate function:
{                                                // must be evaluated at compile-time
    return 42 + i;
}

constexpr int func(int i) 
{
    if consteval {                               // if (std::is_constant_evaluated())...
        return get_value(i);                     // would be improper since it is a runtime check
    } else {
        return 24;
    }
}

constexpr int func1() 
{
    if (std::is_constant_evaluated())... {       // if consteval...
        return 42;                               // is also OK, however...
    } else {                                     // if constexpr () {...
        return 24;                               // will be always true here
    }
}

int main() 
{
    constexpr auto value1 = func1();             // 42
    auto value2 = func1();                       // 24
}
%%


/// basics: ++i vs i++
struct MyInt {
    constexpr MyInt& operator++()                // pre-increment
    {                                            // increment and return the new value
        ++value;
        return *this;
    }
    
    constexpr MyInt operator++(int)              // post-increment
    {                                            // increment and return the previous value
        const auto previous = *this;
        value++;
        return previous;
    }
    
    int value;
};

int main() 
{
    MyInt v{2};                                  // 2
    ++v;                                         // 3
    v++;                                         // 3
    return v.value;                              // 4
}
%%


/// crash course: calendars, dates, time, time zones
# Marc Gregoire, CppCon 2021

#include <ratio>
using r1 = ratio<1,60>;                          // compile-time rational number 1/60
intmax_t num{r1::num};                           // numerator
intmax_t den{r1::den};                           // denominator

intmax_t n{1};
intmax_t d{60};
using r1 = ratio<n,d>;                           // error

using r1 = ratio<1,60>;                          // 1/60
using r2 = ratio<1,30>;                          // 1/30
using result = ratio_add<r1,r2>::type;           // 1/20

using res = ratio_less<r2,r1>;
cout << format("r2<r1: {}", res::value);         // false; not std::ratio_less


# Predefined SI type aliases:
# atto, femto, pico, nano, micro, milli, centi, deci, deca, hecto, kilo, mega, giga, tera, peta, exa

duration<long, ratio<1>> d1;                     // d1 -> (internal type, epoch)
duration<long> d1;                               // ticks of 1 second
duration<long, ratio<60>> d2;                    // ticks of 1 minute
duration<double, ratio<1,60>> d3;                // ticks of 60th of a second
duration<long long, milli> d4;                   // predefined SI rational constants

duration<long, ratio<60>> d3{10};                // 10 minutes
duration<long, ratio<1>> d4{14};                 // 14 seconds
if (d3 > d4) { cout << "d3 > d4"; }
++d4;                                            // 15sec
d4 *= 2;                                         // 30sec

duration<double, ratio<60>> d4{d3 + d4};
duration<long, ratio<1>> d6{d3 + d4};
cout << format("{}min+{}sec", d3.count(), d4.count());     // 10min + 30sec
cout << format("{}min or {}sec", d5.count(), d6.count());  // 10.5min or 630sec

duration<long> d7{30};
duration<double, ratio<60>> d8{d7};
cout << format("{}sec={}min", d7.count(), d8.count());     // 30sec = 0.5min
duration<long, ratio<60>> d8{d7};                          // error; minutes
auto d8{duration_cast<duration<long, ratio<60>>>(d7)};     // 0


# Predefined durations in std::chrono:
# nanoseconds, microseconds, milliseconds, seconds, minutes, hours, hours, days, weeks, years, months
# Literals: h, min, s, ms, us, ns
# namespaces: std, std::literals, std::chrono_literals, std::literals::chrono_literals

duration<long, ratio<60>> d9{10};                // equivalents
minutes d9{10};
auto d9{10min};

auto t{hours{1} + minutes{23} + seconds{45}}
seconds s{90};
minutes m{s};                                    // error; predefined durations use integral types
duration<double, ratio<60>> m{s};                // 1.5min


# std::chrono
# std::system_clock — wall clock time from system-wide real-time clock (Unix Time from C++20, non-monotonic)
# std::steady_clock — guarantees it never goes backwards
# std::high_resolution_clock — has shortest possible tick period (not portable, alias to the previous ones)
# utc_clock — C++20, Universal Time Coordinated, includes leap seconds
# tai_clock — C++20, Time Atomic International, no leap seconds
# gps_clock — C++20, Global Positioning System, no leap seconds
# file_clock — C++20, used in ::filesystem
# now() method

system_clock::time_point tpoint{system_clock::now()};
auto tpoint{system_clock::now()};
time_t tt{system_clock::to_time_t(tpoint)};
tm* t{localtime(&tt)};
cout << put_time(t, "%H:%M:%S");

auto start{high_resolution_clock::now()};
executeCodeToBenchmark();
auto end{high_resolution_clock::now()};
auto diff{end - start};
cout << duration<double,milli>{diff}.count() << "ms";


time_point<steady_clock> tp1;
tp1 += minutes{10};
auto d1{tp1.time_since_epoch()};
duration<double> d2{d1};
cout << d2.count() << " seconds";                // 600 seconds

time_point<steady_clock, seconds> tpSeconds{42s};
time_point<steady_clock, milliseconds> tpMilliseconds{tpSeconds};
cout << tpMilliseconds.time_since_epoch().count() << "ms";           // 42'000ms

time_point<steady_clock, milliseconds> tpMilliseconds{42'016ms};
time_point<steady_clock, seconds> tpSeconds{time_point_cast<seconds>(tpMilliseconds)};
auto tpSeconds{time_point_cast<seconds>(tpMilliseconds)};
milliseconds ms{tpSeconds.time_since_epoch()};
cout << ms.count() << "ms";                                          // 42'000ms


# dates
year y1{2021}; auto y2{2021y};
month m1{10};  auto m2{October};
day d1{27};    auto d2{27d};

year_month_day fulldate1{2021y, October, 27d};
auto fulldate2{2021y / October / 27d};
auto fulldate3{27d / October / 2021y};
year_month_day fulldate4{Wednesday[4] / October / 2021};
auto oct27{October / 27d};                                           // unspecified year
auto oct27_2021{2021y / oct27};

auto lastDayOfAnOctober{October / last};
auto lastDayOfOct2021{2021y / lastDayOfAnOctober};
auto lastMondayOfOct2021{2021y / October / Monday[last]};


# year_month_day — field-based date representation
# sys_time, sys_seconds, sys_days — serial-based date representation
auto today{floor<days>(system_clock::now())};
system_clock::time_point t1{sys_days{2020y / June / 22d}};
year_month_day yearmonthday{floor<days>(t1)};
year_month_day today2{floor<days>(system_clock::now())};

auto d2{sys_days{2020y/June/22d} + 9h + 35min + 10s};
auto d3{d2 + days{5}};
cout << d2 << '\n' << d3;    // 2020-06-22 09:35:10 \n 2020-06-27 09:35:10
auto d4{d2 + years{1}};
cout << d2 << '\n' << d4;    // 2020-06-22 09:35:10 \n 2021-06-22 15:24:22
// adding 1 year with a leap sec: 86'400*(((365*400)+97)/400)=31'556'952 seconds


# time zones
const auto& database{std::chrono::get_tzdb()};
for (const auto& timezone : database.zones) { cout << timezone.name() << endl; }

auto* brussels{locate_zone("Europe/Brussels")};
auto* gmt{locate_zone("GMT")};
auto* current{current_zone()};

gmt->to_local(system_clock::now());
auto t{sys_days{2020y/June/22d} + 9h + 35min + 10s};
brussels->to_local(t);
zoned_time<hours> brusselsTime{brussels, local_days{2020y/June/22d} + 9h};
zoned_time<hours> newYorkTime{"America/New_York", brusselsTime};
%%


/// software design: extended/extensible Factory pattern
# Mike Shah, CppCon 2021

class IGameObject {
  public:
    virtual ~IGameObject() {}
    virtual void update() = 0;
    virtual void render() = 0;
};

class MyGameObjectFactory {
    typedef IGameObject *(*CreateObjectCallback)();
    
  public:
    static void Register(const std::string& type, CreateObjectCallback cb) {
        s_objects[type] = cb;
    }
    
    static void Unregister(const std::string& type) {
        s_objects.erase(type);
    }
    
    static IGameObject* CreateSingle(const std::string& type) {
        CallBackMap::iterator it = s_objects.find(type);
        
        if (it != s_objects.end()) {
            return (it->second)();
        }
        
        return nullptr;
    }
    
  private:
    typedef std::unordered_map<std::string, CreateObjectCallback> CallBackMap;
    static CallBackMap s_objects;
};

MyGameObjectFactory::CallBackMap MyGameObjectFactory::s_objects;


class Boat : public IGameObject {
  public:
    void update() {}
    void render() {}
    static IGameObject* Create() { return new Boat(); }
};

int main() {
    MyGameObjectFactory::Register("boat", Boat::Create);

    std::vector<IGameObject*> gameObjects;
    std::string line;
    std::ifstream myFile("objects_to_create.txt");
    
    if (myFile.is_open()) {
        while (std::getline(myFile, line)) {
            IGameObject* obj = MyGameObjectFactory::CreateSingle(line);
            gameObjects.push_back(obj);
        }
    }
    
    while (inGameMainLoop()) {
        for (auto& e : gameObjects) {
            e->update();
            e->render();
        }
    }
}
%%


/// winrt: COM asynchronous release
struct SyncForRelease : winrt::implements<SyncForRelease, ISynchronize> {
    winrt::com_ptr<::IUknown> m_inner;
    ::AsyncIUknown* m_async_unknown;
    
    int32_t query_interface_tearoff(winrt::guid const& id, void** object) const noexcept override {
        if (m_inner) return m_inner.as(id, object);
        return E_NOINTERFACE;
    }
    
    auto Sync() noexcept {
        return m_inner.as<ISynchronize>();
    }
    
    STDMETHODIMP Reset() {
        return Sync()->Reset();
    }
    
    STDMETHODIMP Signal() {
        auto hr = Sync()->Signal();
        m_async_unknown->Finish_Release();
        m_inner.detach();                                  // don't Release it
        Release();                                         // I am dead to me
        return hr;
    }
    
    STDMETHODIMP Wait(DWORD flags, DWORD timeout) {
        return Sync()->Wait(flags, timeout);
    }
    
    void ReleaseAsynchronously(IUknown* unknown) {
        winrt::com_ptr<::ICallFactory> factory;
        unknown->QueryInterface(IID_PPV_ARGS(factory.put()));
        unknown->Release();
        if (!factory) return;
        winrt::com_ptr<SyncForRelease> sync;
        
        try {
            sync = winrt::make_self<SyncForRelease>();
        }
        catch (std::bad_alloc const&) {
            if (!sync) return;
        }
        
        factory->CreateCall(
            __uuidof(::AsyncIUnknown), sync.get(),
            __uuidof(::IUnknown), sync->m_inner.put()
        );
        factory = nullptr;
        if (!sync->m_inner) return;                        // Release + AddRef cancel out
        sync->m_async_unknown->Begin_Release();
    }
};
%%


/// testing: mocks etc.
# https://google.github.io/googletest/gmock_for_dummies.html

# Mocks are objects that implements the same interface as the original objects.
# Stubs can be configured to respond from the system under tests with the values or exceptions.
# Spies are stubs with memory of what has been answered previously.
# Fakes have lightweight implementation that might return hardcoded data, always valid/invalid.

# https://github.com/QuantlabFinancial/cpp_tip_of_the_week/blob/master/217.md
# Fake - an object with limited capabilities
# Stub - an object that provides predefined answers to method calls and record calls
# Mock - an object on which you set expectations which are verified by itself

class Car {
  public:
    virtual ~Car() = default;
    virtual void startEngine() = 0;
    virtual int getTrunkSize() const = 0;
    virtual void addFuel(double quantity) = 0;
};

class MockCar : public Car {                               // mock an interface with a gMock
  public:
    MOCK_METHOD(void, startEngine, (), (override));        // return_type, method_name,
    MOCK_METHOD(int, getTrunkSize, (), (const, override)); // (parameter_types_list),
    MOCK_METHOD(void, addFuel, (double), (override));      // (function_qualifiers_list)
};

# In C++ it's easier to mock a virtual function than a non-virtual one.
# gMock allows to create mocks that are also stubs.
# Matchers can be chained with different optional clauses.

ON_CALL(c, addFuel(5.0));                                  // 1. describe expectations:
ON_CALL(c, addFuel(::testing::_));                         // wildcard
ON_CALL(c, addFuel(::testing::Gt(5)));                     // greater than comparison
ON_CALL(o, foo(1).WillByDefault(::testing::Return(42)));   // provide behaviour

EXPECT_CALL(c, getTrunkSize());                                           // 2. describe & assert:
EXPECT_CALL(c, addFuel(5.0)).Times(::testing::Times(2));                  // cardinality
EXPECT_CALL(c, getTrunkSize()).WillRepeatedly(::testing::Return(420));    // define an action

ON_CALL(c, startEngine()).WillByDefault([&c](){
    return c.Car::startEngine();                                          // fall back to original
});


# AAA pattern: Arrange, Act, Assert
# BDT (Behaviour-Driven Testing): Given, When, Then
# while dealing with mocks: arrange, set expectations and reactions (assert), act (execute)
%%


/// windows: filter out fake keyboards from GetRawInputDeviceList
bool smells_like_a_real_keyboard(HANDLE hDevice)
{
    RID_DEVICE_INFO info;
    UINT size = sizeof(info);
    UINT actualSize = GetRawInputDeviceInfoW(hDevice, RIDI_DEVICEINFO, &info, &size);
    
    if (actualSize == (UINT)(-1) || actualSize < sizeof(info)) {
        // weird failure
        return false;
    }
    
    assert(info.dwType == RIM_TYPEKEYBOARD);
    return info.keyboard.dwNumberOfKeysTotal >= 30;
}

int main(int argc, char** argv)
{
    auto devices = GetRawInputDevices();
    int nMouse = 0;
    int nKeyboard = 0;
    int nOther = 0;
    
    for (auto const& device : devices) {
        switch (device.dwType) {
          case RIM_TYPEKEYBOARD:
            if (smells_like_a_real_keyboard(device.hDevice)) ++nKeyboard; break;
          case RIM_TYPEMOUSE:
            ++nMouse; break;
          default:
            ++nOther;
        }
    }
    
    printf("There are %d keyboards, %d mice, and %d other things\n", nKeyboard, nMouse, nOther);
    return 0;
}
%%


/// optimization example: darkening a bitmap
# Raymond Chen, 2022
# The goal: to make a 32bpp ARGB image a little darker

union Pixel {
    uint8_t c[4];            // 4 channels: red, green, blue, alpha
    uint32_t v;              // full pixel value as a 32-bit integer
};

// plain version
// naive approach: going through every pixel and applying the darkening factor to three channels
void darken(Pixel* first, Pixel* last, int darkness) 
{
    // darkness == 0      no change at all
    // darkness == 256    complete blackness
    int ligthness = 256 - darkness;
    
    for ( ; first<last; ++first) {
        for (int i=0; i<3; ++i) {
            first->c[i] = (uint8_t)(first->c[i] * ligthness / 256);
        }
    }
}

// idea: unroll the innermost loop
// 1.8x faster than the plain version
void darken(Pixel* first, Pixel* last, int darkness)
{
    int lightness = 256 - darkness;
    
    for ( ; first<last; ++first) {
        first->c[0] = (uint8_t)(first->c[0] * lightness / 256);
        first->c[1] = (uint8_t)(first->c[1] * lightness / 256);
        first->c[2] = (uint8_t)(first->c[2] * lightness / 256);
    }
}

// idea: doing the operations in parallel; SWAR (SIMD within a register)
// 2.9x slower than the non-parallel version
constexpr unsigned pack_fields(uint8_t r, uint8_t g, uint8_t b)
{
    return r | (g << 10) | (b << 20);
}

void darken(Pixel* first, Pixel* last, int darkness) 
{
    // the idea here is to break the 32-bit integer into the respective channels,
    // but spread them out so they act like independent lanes of a SIMD register
    // after that we perform a single multiplication on all lanes (distributive law)

    // program uses only 3 darkness values: 8, 16, 24 (lightning factors: 248, 240, 232)
    // thus, ligthning factor can be simplified: newPixel = oldPixel * (lightness/8)/32
    // or: newPixel = oldPixel - ceil(oldPixel * (darkness/8)/32)

    // arrange 3 channel values inside a 32-bit integer like this:
    // value[ 0: 9] = red
    // value[10:19] = green
    // value[20:29] = blue
    // value[30:31] → unused
    
    int factor = darkness / 8;
    
    for ( ; first<last; ++first) {
        uint32_t fields = pack_fields(first->c[0], first->c[1], first->c[2]);
        fields *= factor;
        fields += pack_fields(31, 31, 31);
        first->c[0] -= (fields >>  5) & 31;
        first->c[1] -= (fields >> 15) & 31;
        first->c[2] -= (fields >> 25) & 31;
    }
}

// idea: load and store entire pixels at a time
// 2.1x slower than the non-parallel version
void darken(Pixel* first, Pixel* last, int darkness)
{
    int factor = darkness / 8;
    
    for ( ; first<last; ++first) {
        uint32_t v = first->v;
        uint32_t fields = (v & 0xFF) | ((v & 0xFF00) << 2) | ((v & 0xFF0000) << 4);
        fields *= factor;
        fields += pack_fields(31, 31, 31);
        uint32_t diff = ((fields >> 5) & 0x1F) | ((fields >> 7) & 0x1F00) | ((fields >> 9) & 0x1F0000);
        first->v = v - diff;
    }
}

// idea: don't waste time to build up the difference fields
// 2.1x slower than the non-parallel version
void darken(Pixel* first, Pixel* last, int darkness)
{
    int factor = darkness / 8;
    
    for ( ; first<last; ++first) {
        uint32_t v = first->v;
        uint32_t fields = (v & 0xFF) | ((v & 0xFF00) << 2) | ((v & 0xFF0000) << 4);
        fields *= factor;
        fields += pack_fields(31, 31, 31);
        v -= (fields >> 5) & 0x1F; 
        v -= (fields >> 7) & 0x1F00;
        v -= (fields >> 9) & 0x1F0000;
        first->v = v;
    }
}

// idea: the darkness factor is known to  be 1, 2, or 3
// 2.2x slower than the non-parallel version
void darken(Pixel* first, Pixel* last, int darkness) 
{
    // factor     mask2        mask3    (fields & mask2) + (fields & mask3)
    //   1     0x00000000   0x00000000        0          +      0
    //   2     0xFFFFFFFF   0x00000000      fields       +      0 
    //   3     0xFFFFFFFF   0xFFFFFFFF      fields       +   fields

    int factor = darkness / 8;
    uint32_t mask2 = factor >= 2 ? 0xFFFFFFFF : 0;
    uint32_t mask3 = factor >= 3 ? 0xFFFFFFFF : 0;
    
    for ( ; first<last; ++first) {
        uint32_t v = first->v;
        uint32_t fields = (v & 0xFF) | ((v & 0xFF00) << 2) | ((v & 0xFF0000) << 4);
        fields += (fields & mask2) + (fields & mask3);
        fields += pack_fields(31, 31, 31);
        v -= (fields >> 5) & 0x1F;
        v -= (fields >> 7) & 0x1F00;
        v -= (fields >> 9) & 0x1F0000;
        first->v = v;
    }
}

// idea: let's just do real SIMD using the x86 intrinsics, limiting to SSE2
// 3.5x faster than the non-SIMD version
void darken(Pixel* first, Pixel* last, int darkness)
{
    // let's assume that the start of the pixel array is aligned on a 16-byte boundary
    // and the total size is a perfect multiple of 16 (this skips the edge cases)

    // lightness128   8 16-bit lanes
    // val            16 bytes for SSE2 register

    int lightness = 256 - darkness;
    using l = lightness;
    auto lightness128 = _mm_set_epi16(256, l, l, l, 256, l, l, l);
    void* end = last;
    
    for (auto pixels = (__m128i*)first; pixels<end; pixels++) {
        auto val = _mm_loadu_si128(pixels);
        auto vlo = _mm_unpacklo_epi8(val, _mm_setzero_si128());
        vlo = _mm_mullo_epi16(vlo, alpha128);
        vlo = _mm_srli_epi16(vlo, 8);
        auto vhi = _mm_unpackhi_epi8(val, _mm_setzero_si128());
        vhi = _mm_mullo_epi16(vhi, alpha128);
        vhi = _mm_srli_epi16(vhi, 8);
        val = _mm_packus_epi16(vlo, vhi);
        _mm_storeu_si128(pixels, val);
    }
}

// idea: use ARM Neon intrinsics instead of x86 SSE intrinsics
// faster than non-SIMD version on AArch64 architecture (can be emulated using QEMU)
void darken(Pixel* first, Pixel* last, int darkness)
{
    // we broadcast the lightness value to all the lanes, and then set lanes 3 and 7
    // explicitly to 256; val goes into a register; we zip 16-byte register with a register
    // full of zeroes, which interleaves low and high bytes
    
    int lightness = 256 - darkness;
    uint16x8_t lightness128 = vdupq_n_u16((uint16_t)lightness);
    lightness128 = vsetq_lane_u16(256, lightness128, 3);
    lightness128 = vsetq_lane_u16(256, lightness128, 7);
    void* end = last;
    
    for (auto pixels = (uint8_t*)first; pixels<end; pixels+=16) {
        uint8x16_t val = vld1q_u8(pixels);
        uint8x16x2_t zipped = vzipq_u8(val, vdupq_n_u8(0));
        uint16x8_t lo = vreinterpretq_u16_u8(zipped.val[0]);
        lo = vmulq_u16(lo, lightness128);
        auto hi = vreinterpretq_u16_u8(zipped.val[1]);
        hi = vmulq_u16(hi, lightness128);
        val = vuzpq_u8(vreinterpretq_u8_u16(lo), vreinterpretq_u8_u16(hi)).val[1];
        vst1q_u8(pixels, val);
    }
}
%%


/// issue: make compile-time string a run-time string
# Jason Turner, 2022

// make run-time string
constexpr std::string make_string(std::string_view base, const int repeat)
{
  std::string retval;
  for (int count=0; count<repeat; ++count) { retval += base; }
  return retval;
}

// this will be optimized by a compiler
struct oversized_array { 
  std::array<char, 10*1024*1024> data[];
  std::size_t size;
};

// obtain the size at a run-time
constexpr auto to_oversized_array(const std::string& str) 
{ 
  oversized_array result;
  std::copy(str.begin(), str.end(), result.data.begin());
  result.size = str.size();
  return result;
}

// we may use a lambda to do constexpr work outside of constexpr context
consteval auto to_right_sized_array(auto callable)
{
  constexpr auto oversized = to_oversized_array(callable());
  std::array<char, oversized.size> result;
  std::copy(oversized.data.begin(), std::next(oversized.data.begin(), oversized.size), result.begin());
  return result;
}

// this will instantiate as a concrete type, e.g. std::array<char,36ul>{char[36]{(char)72, ...}}
template<auto Data> consteval const auto& make_static()
{
  return Data;
}

// the data will go on stack like a constexpr static data
consteval auto to_string_view(auto callable) -> std::string_view 
{
  constexpr auto& static_data = make_static<to_right_sized_array(callable)>();
  return std::string_view(static_data.begin(), static_data.size());
}

int main()
{
  constexpr auto make_data = [](){ return make_string("Hello Jason,", 3); };
  constexpr static auto sv = to_string_view(make_data);
  fmt::print("{} : {}", sv.size(), sv);  
}
%%


/// constexpr/consteval: force compiler to do work at compile-time
# Jason Turner, 2022

constexpr int get_value(int value) 
{
  return value*3;
}

consteval int get_value_consteval(int value)
{
  return value*4;
}

template<auto Value> 
consteval const auto make_compile_time()
{
  return Value;
}

consteval auto as_constant(auto value)
{
  return value;
}

int main()
{
  constexpr auto value = get_value(42);               // not guaranteed, is const
  constexpr static auto value2 = get_value(42);       // has to be const, static
  constinit static auto value3 = get_value(43);       // has to be static, not const
  auto value4 = get_value_consteval(44);              // must be a compile-time const, consteval fun
  auto value5 = make_compile_time<get_value(45)>();
  auto value6 = as_constant(get_value(46));
  return value + value2 + value3 + value4 + value5 + value6;
}
%%


/// shared_ptr: enable_shared_from_this
# Back to Basics: Smart Pointers and RAII, Inbal Levi, CppCon 2021

auto get_device(const std::string& serialNumber) {
    return std::make_shared<Device>(serialNumber);
}

class Device : public std::enable_shared_from_this<Device> {
    std::string m_sn;
    Device(const std::string& sn) : m_sn(sn) {}
  public:
    static std::shared_ptr<Device> CreateDevice(const std::string& sn) {
        return std::shared_ptr<Device>(new Device(sn));
    }
    std::shared_ptr<Device> getHandle() {
        return shared_from_this();
    }
};

int main() 
{
    auto dev = get_device("1234");
    auto dev1 = Device::CreateDevice("1111");
    auto dev2 = dev1->getHandle();
}
%%


/// software quality: Zen and the Art of Code Lifecycle Maintenance
# Phil Nash, CppCon 2021

# structural quality:            Mr Crap or CAREER:
                                 applicability                  do the right thing
  security                       correctness                    do the thing right
  reliability                    reliability                    code (TDD) + data coverage (PBT)
  performance efficiency         performance/efficiency         how fast code executes
  maintainability                malleability/evolvability      ability to reason about change in code
                                 reasonability                  ability to reason about the code

correctness vs applicability     do the right thing vs do the thing right
correctness vs reliability       code coverage (line, data) + error paths (IO, contracts)
reasonability vs evolvability    complexity vs simplicity (testing, reasoning, changing)
reasonability vs efficiency      consider as opposed to each other (techniques such as IILI, PBT)

applicability — correctness — reliability        →  types, tests, error-handling
evolvability — reasonability — efficiency        →  zen on code (meditation, awareness)


PBT — Property-Based Testing
'Therefore, it is better to do the right thing wrong than the wrong thing right.' — Russell L. Ackoff
'Do it Right, Then, Do the Right thing' — Allan Kelly; only by actually doing we can know what is right to do (try, fail, try again, learn, reconsider, try differently)
complexity: threading/concurrency, globals/singletons, other shared state, mutability, cyclomatic complexity, code/module dependencies
simple code is easy to: test, reason about, change; achieve by introducing functional programming


// purpose: validate range 1-12 only once
class Month {
    uint8_t month;

  public:
    constexpr Month(uint8_t month) : month(month) {
        if (!is_valid_month(month)) throw std::domain_error("month must be within 1-12");
    }
    
    constexpr Month(uint8_t month, unchecked_tag) : month(month) {
        // purpose: express your intent
        assert(is_valid_month(month));
    }
    
    [[nodiscard]] constexpr uint8_t get() const {
        return month;
    }
};

int main()
{
    Month m1(13);                                // throws
    Month m2(13, unchecked_tag());               // asserts
    
    // IILI — Immediately Invoked Lambda Expression
    const auto state = [trafficLight]{
        switch (trafficLight) {
            case TrafficLight::Red:   return State::Stopped;
            case TrafficLight::Amber: return State::GetReady;
            case TrafficLight::Green: return State::Driving;
        }
    }();
}

// PBT example
int slow_but_easy_algorithm(int i1, int i2);
int fast_but_tricky_algorithm(int i1, int i2);
int i1 = GENERATE(take(100, random(INT_MIN, INT_MAX)));
int i2 = GENERATE(take(100, random(INT_MIN, INT_MAX)));
REQUIRE(slow_but_easy_algorithm(i1, i2) == fast_but_tricky_algorithm(i1, i2));
%%


/// game design: game loop managing with threads
# Combining Co-Routines and Functions into a Job System, Helmut Hlavacs, CppCon 2021

# (1) GLOBAL_QUEUE → threads_per_core
no threads outside thread pool; work stealing for load balancing; local & globals queues; continuations;
consider: Active object per core

# (2) tagged scheduling
schedule(f());
schedule(g(), tag_t{2});
%%


/// C++20 modules: introduction
# Any file containing the module syntax is referred to as a Module Unit.
# A Named Module may be made up of one or more Module Units.

# There is no one way of +correctly+ using C++20 modules:
# (1) single file module → Java, Python
# (2) interface file + implementation file → Ada
# (3) partitions (multiple separate files) → C++20 model

# At compilation headers don't exist.
# All declarations and definitions are private unless exported (Module Linkage).
# Namespaces are orthogonal to modules.


module;                                          // func.cxx:
#include <iostream>                              // global module fragment

export module mod;                               // the main module purview

export void func() {
    std::cout << "Hello, module!";
}
                                                 // private fragment
                                                 // module interface that may affect other TUs
                                                 // can appear only in single-file modules (complete)

import mod;                                      // main.cpp:
                                                 // g++ -c -std=c++20 -fmodules-ts func.cxx
int main() {                                     // g++ -c -std=c++20 -fmodules-ts main.cpp
    func();                                      // g++ main.o func.o -o App
}                                                // ./App



export module mod;                               // func.cxx:
export void func();                              // PMIU — Primary Module Interface Unit
                                                 // g++ -c -std=c++20 -fmodules-ts func.cxx

module;                                          // func_impl.cxx:
#include <iostream>                              // MIU — Module Implementation Unit

module mod;                                      // IUs cannot have any export statements!

void func() {                                    // g++ -c -std=c++20 -fmodules-ts func_impl.cxx
    std::cout << "Hello, module!";               // g++ main.o func.o func_impl.o -o App
}                                                // ./App



export module mod;

export {                                         // export block
    void func();
    void func(int);
}

export namespace x {                             // exceptions: templates, ADL evaluation
    void xfunc();
}

export class S {
  public:
    explicit S(int p) : val(p{}) {}
    int get_val() const;
    
  private:
    int val{};
};

export void func_s(const S&);



#ifndef _HEADER_                                 // header.h: (header-only file)
#define _HEADER_
                                                 // g++ -c -std=c++20 -fmodule-header header.h
constexpr int life = 42;                         // header.h.gcm

#endif                                           // import "header.h";

%%


/// design: curry function in C++20
# We transform a function with multiple arguments into a sequence of nesting functions.
# It returns a new function that expects the next argument inline.

function add(a, b, c) {                          // JavaScript
    return a + b + c;
}

function add(a) {
    return function(b) {
        return function(c) {
            return a + b + c;
        }
    }
}

add(1)(2)(3);                                    // 6
add(3)(4)(5);                                    // 12

                                                 // partially applied function:
var add3 = add(11, 1);                           // function(11, 1, c){ return 11 + 1 + c; }
add3(22);                                        // 34

# Currying is used when we want to have pre-configured behave of our program.
# Also helps us avoid often call function with same parameter.


template<typename Callable, typename... Params>  // everything is handled by copy !
auto curry(Callable f, Params... ps)
{
    if constexpr (requires{ f(ps...); }) {       // if is incovable then call
        return f(ps...);
    }
    
    return [f, ps...](auto... qs) {              // otherwise return packed function
        return curry(f, ps..., qs...);
    };
}

int func1(int x, int y, int z) 
{
    return x + y + z;
}

int main()
{
    [[maybe_unused]] const auto bound1 = curry(func1, 1, 2, 3);                // 6
    [[maybe_unused]] const auto bound2 = curry(func1, 1, 2)(3);                // 6
    [[maybe_unused]] const auto bound3 = curry(func1)(1)(2)(3);                // 6
    [[maybe_unused]] const auto bound4 = curry(func1, 1, 2)()()()(3);          // 6
    return 0;
}
%%


/// C++: noexcept specifier and operator
# CppCon 2021, John Lakos, Embracing 'noexcept' Operators and Specifiers Safely

# Throwing: throw(something), noexcept(false)
# Non-throwing: throw(), noexcept(true), noexcept

# noexcept(f()) → f() is invoked at compile-time; result converted to bool
# noexcept(noexcept(f())) → outer specifier + inner operator; noexcept operator will return false if and only if the invocation of f() is permitted to emit an exception

# When to apply noexcept specifier?
# constructors, destructors, move semantics, swap/size/is_bool functions, and the like
%%


/// C++: std::map
# https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20

std::map<std::string, int> myMap;
if (myMap.find(aKey) != myMap.end()) {                               // before C++20
if (myMap.contains(aKey)) {                                          // C++20


std::map<std::string, SomeLengthClassName>::const_iterator i;
for (i=myMap.begin(); i!=myMap.end(); ++i) {
    const std::string& key = i->first;
    const SomeLengthClassName& value = i->second;
}
for (const auto& [key, value] : myMap) {                             // C++17 structured binding
for (const auto& [key, _] : myMap) {                                 // _ as in Python


std::map<std::string, int> myMap{ {"one",1},{"two",2},{"three",3} };
for (auto i=myMap.begin(); i!=myMap.end(); ++i) {
for (auto const& value : std::views::values(myMap)) {                // ranges and views
for (auto const& key : std::views::keys(myMap)) {
for (auto const& value : aMap | std::views::keys) {

std::map<bool, std::map<string, std::pair<std::string, int>>> items;
for (std::map<bool,std::map<std::string,int>>::iterator i=items.begin(); p!=items.end(); ++i) {
for (auto i=items.begin(); p!=items.end(); ++i) {
for (std::pair<const K, V>& range : myMap) {
%%


/// C++ design: principles to consider
# https://www.sandordargo.com/blog/2022/04/16/beautiful-cpp-by-kate-gregory-and-guy-davidson

# Bikeshedding is bad
# Don't hurt yourself
# Stop using that
# Use this new thing properly
# Write code well by default

# Where ther is a choice, prefer default arguments over overloading
# Avoid trivial getters and setters
# Specify concepts
# Prefer immutable to mutable data


class Account {
  public:
    std::floating_point getBalance() const;      // what is the invariant?
    void setBalance(std::floating_point);        // what is the purpose of this class existance?
  private:
    std::floating_point balance;
};
struct AccountData {
    std::floating_point balance;                 // wouldn't this be suitable as well?
};
template<design::pattern::Money Money>           // Money { amount,currency; +-*<>=; convert,toString }
class Account {
  public:
    void deposit(Money amount);                  // why not to express your intent better?
    void withdrawn(Money amount);                // why not to provide meaningful behavior?
  private:                                       // would getBalance() here invalidate invariant?
    Money balance;                               // for what we covet a standalone balance anyway?
  /*public:
    Money getBalance() const;*/                  // might eventually be, yet without setBalance()
};
%%


/// design by contract: C++20
# contracts specifies in a checkable way interfaces for software components

int push(queue& q, int val) [[expects: !q.full()]] [[ensures: !q.empty()]]
{
    // expects: preconditions (requirements for input values)
    // ensures: postconditions (requirements for output values)
    // assert: assertion (a predicate for invariants)
    [[assert: q.is_ok()]]
    // predicate: a function that is convertible to a boolean
}

# post- and preconditions are part of a function interface, thus they obey the rules of access levels
# for compilation we may specify build levels: off, default, audit (default+audit)
# if predicates evaluates to false, then the violation handler is invoked (and std::terminate)
# std::contract_violation { line_number(), file_name(), function_name(), comment(), assertion_level() }

# [[contract-attribute modifier: conditional-expression]]
# [[ensures modifier indentifier: conditional-expression]]
#   contract-attribute: expects, ensures, assert
#   modifier: default (runtime, small cost), audit (runtime, large cost), axiom (compile-time)
#   indentifier: an arbitrary name
#   conditional-expression: a predicate (convertible to a boolean)
%%


/// ABI breakage and inline namespace
# C++ Weekly with Jason Turner, Ep. 320, 2022, "Using 'inline namespace' To Save Your ABI"

namespace lefticus {                                  // ABI breakage (binary code changes):
  struct Data {                                       // struct Data {
    char c;                                           //   int i;
    int i;                                            //   char c;
    char c2;                                          //   char c2;
  };                                                  // };
                                                      // different memory layout, different sizes
  int calculate_things(const Data&);                  // UB with previously compiled code, linker errors
}                                                     // ...

int main()
{
  const lefticus::Data some_data{};
  return lefticus::calculate_things(some_data);
}

namespace lefticus {
  namespace v2_0_0 {                                  // no 'inline' implies default choice
    struct Data {
      char c;
      int i;
      char c2;
    };
    
    int calculate_things(const Data&);
  }

  inline namespace v3_0_0 {                           // different linker symbols
    struct Data {                                     // note: C has no name mangling
       int i;                                         // safe change
       char c;
       char c2;                                       // downside:
    };                                                // we have to manually keep track of this
    
    int calculate_things(const Data&);
  }
}

int main() 
{
  const lefticus::Data some_old_data{};               // v2_0_0
  const lefticus::v3_0_0::Data some_data{};           // v3_0_0
  return lefticus::calculate_things(some_data);
}
%%


/// C++: memoization
# CppCon 2021, Chris Philip, "Memoizing Constexpr Programs"

template<int N> constexpr int fib();
template<int N> constexpr int fib_memo = fib<N>();

template<int N> constexpr int fib() {
    if constexpr (N<2) return N;
    else return fib_memo<N-1> + fib_memo<N-2>;
}
%%


/// C++: undefined behavior
# when reaching UB point, the program switches to an undeterministic behavior
# C++ Standard uses terms: UB, implementation defined behavior, unspecified behavior
# undefined behavior is not an error

# iterating over references to a temporary object within ranged-based for loop is UB
# reading past the end of std::vector is UB
# accessing memory that is out-of-bounds (array[-1] == 0) is UB
# invoking the destructor of an object twice is UB
# non-virtual or non-protected destructor in a derived class is potential UB
# if (*this == rhs) check within an object is a potential UB because of compiler optimization
# using a variable x after applying std::move(x) is UB
# using std::binary_search for unsorted data set is UB; true for some other STL algorithm
# doing a bit shift by a negative value is UB
# doing a bit shift when values are too large (f(250,75): x << y) is UB
# simultaneously reading and writing to a variable (++i + i++) is UB
# pre-increment and assignment to the same variable (v = ++v+2) is UB in some C++ Standard versions
# converting a double to a float when the value is too large is UB
# dereferencing a null pointer is UB
# accessing an uninitialized variable is UB
# calling a pure virtual function from a constructor or destructor is UB
# use of an object after it has been destroyed (use-after-free) is UB
# casting a pointer to an incompatible type and the using the result is UB
# infinite loop without side effects is UB
# modifying a string literal or any other const objects is UB
# using an lvalue for printf formatting string is UB
# failing to return a value from a value-returning function is UB
# any race condition is UB
# integer divide by zero is UB
# signed integer overflow is UB
# specializing a type trait which exists in the std namespace is UB


std::vector<std::string> createStrings() {
  return { "This", "is", "a", "vector", "of", "strings" };
}
int main() {
  for (auto w : createStrings()[0]) {
    std::cout << w << " ";                                           // UB
  }
}

std::optional<std::vector<int>> createOptionals() {
  return std::optional<std::vector<int>>
}
int main() {
  for (auto i : createOptionals().value()) {
    std::cout << i << " ";                                           // UB
  }
  // ranged-based for loop is transformed into a for loop:
  //   auto&& range = createOptionals().values();
  //   auto position = range.begin();
  //   auto end = range.end();
  //   for ( ; position != end; ++position) {
  //     std::cout << *(position) << " ";
  //   }
}

bool monthOfCppCon21() {                                             // UB if allowed
  someData == "October";                                             // because of no return
}

void doThing8(const std::string& input) {                            // UB if
  std::string& tmp = const_cast<std::string&>(input);                // argument passed 'input'
  tmp = "bear";                                                      // is const qualified
}

void loop_with_no_side_effects() {                                   // UB
  for( ; ; ) {}                                                      // recognized by community
}
%%


/// design: factory that remembers parameters passed
template<typename T, typename... Args>
struct GenericFactory {
  using Arguments = std::tuple<std::decay_t<Args>...>;
  const Arguments captured;
  
  GenericFactory(Args&&... args) : captured(std::forward<Args>(args)...) {}
  
  auto make() {
    return std::apply(std::make_unique<T, std::decay_t<Args> const&...>, captured);
  }
};

template<typename T, typename... Args>
auto makeGenericFactory(Args&&... args) {
  return GenericFactory<T, Args...>(std::forward<Args>(args)...);
}

template<typename T, typename... Args>
auto makeGenericFactory2(Args&&... args) {
  return [captured = std::make_tuple(args...)]() {
    return std::apply(std::make_unique<T, std::decay_t<Args> const&...>, captured);
  };
}

template<typename T, typename... Args>
auto makeGenericFactory3(Args&&... args) {
  return [...args = std::forward<Args>(args)]() {
    return std::make_unique<T>(args...);
  };
}
%%


/// C++: NTTP (Non-Type Template Parameters) example
template<std::size_t N> struct fixed_string final {
  constexpr explicit(false) fixed_string(const char (&str)[N+1]) 
  {
    std::copy_n(str, N+1, std::data(data));
  }  
  
  [[nodiscard]] constexpr auto operator<=>(const fixed_string&) const = default;
  
  std::array<char, N+1> data{};
};

template<std::size_t N>
fixed_string(const char (&str)[N]) -> fixed_string<N-1>;

template<fixed_string> struct foo;


int main() 
{
  what_is_my_type<"Quantlab">{};
}
%%


/// testing: specification-based techniques
# equivalence partitioning (equivalence class partitioning)
# boundary value analysis
# decision table testing
# state transition testing
# use case testing
%%


/// winrt: windows runtime type
template<typename T>
constexpr T winrt_empty_value() noexcept
{
  if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUknown, T>) {
    return nullptr;
  } 
  else {
    return {};
  }
}
%%


/// winrt: awaiting a task with a timeout
template<typename First, typename... Rest>
First when_any_cancel_others(First first, Rest... rest)
{
  auto cleanup = std::make_tuple(
    wil::scope_exit([&] { first.Cancel(); }),
    wil::scope_exit([&] { rest.Cancel(); })...
  );
  
  return co_await winrt::when_any(first, rest...);
}

template<
  typename Async, 
  typename Result = decltype(std::declval<Async>().GetResults()),
  typename std::enable_if_t<std::is_same_v<Result, void>, int> = 0
>
Async when_complete_or_timeout(Async async, TimeSpan delay)
{
  return when_any_cancel_others(async,
    [](TimeSpan delay) -> Async {
      (co_await winrt::get_cancellation_token()).enable_propagation();
      co_await winrt::resume_after(delay)
    }(delay)
  );
}

template<
  typename Async,
  typename Result = decltype(std::declval<Async>().GetResults()),
  typename std::enable_if_t<!std::is_same_v<Result, void>, int = 0>
>
Async when_complete_or_timeout(Async async, TimeSpan delay, Result fallback = winrt_empty_value<Result>())
{
  return when_any_cancel_others(async,
    [](TimeSpan delay, Result fallback) -> Async {
      (co_await winrt::get_cancellation_token()).enable_propagation();
      co_await winrt::resume_after(delay);
      co_return fallback;
    }(delay, std::move(fallback))
  );
}

template<typename Async>
Async when_complete_or_timeout_exception(Async async, TimeSpan delay)
{
  return when_any_cancel_others(async,
    [](TimeSpan delay) -> Async {
      (co_await winrt::get_cancellation_token()).enable_propagation();
      co_await winrt::resume_after(delay);
      throw winrt::hresult_error(HRESULT_FROM_WIN32(ERROR_TIMEOUT));
    }(delay)
  );
}
%%


/// c++: where to not use const?
# C++ Weekly with Jason Turner, Ep. 322, 2022

struct S {
  S()                                  { puts("S()"); }
  S(const S&)                          { puts("S(const S&)"); }
  S(S&&) noexcept                      { puts("S(S&&)"); }
  ~S() noexcept                        { puts("~S()"); }
  S& operator=(const S&)               { puts("operator=(const S&)");     return *this; }
  S& operator=(S&&) noexcept           { puts("operator=(S&&)");          return *this; }
};


# don't const any member data (it breaks implicit and explicit moves, it breaks common use cases of assignment; for invariants write some accessors)
struct Data {
  const S s;
};
int main() {
  Data d;                              // consider: data.vector_data.emplace_back()
  d = Data{};                          // Data& Data::operator=(Data&&) is implicitly deleted
  Data d2 = std::move(d);              // S(), S(const S&), ~S(), ~S()
}

# don't const non-trivial value parameters that you might need to return directly from the function
inline S make_value_2(const S s) {     // without const: S(), S(S&&), ~S(), ~S()
  return s;                            // clang warning: constness of 's' prevents automatic move
}
int main([[maybe_unused]] int argc, const char*[]) {
  auto s = make_value_2(S{});          // S(), S(const S&), ~S(), ~S()
}

# if you have multiple different objects that might be returned, then you are also relying on implicit move-on-return (aka automatic move)
# don't const local values that need take advantage of implicit move-on-return operations
inline std::optional<S> make_value_3() {
  const S s;                           // object type mismatch return type
  return s;
}
inline S make_value_3_2(bool option) {
  if (option) { S s;   return s; }     // if only 'return S{}', then: S(), S(), ~S(), ~S()
  else        { S s2;  return s; }     // if 'const S', then: S(), S(const S&), ~S(), ~S()
}
int main(int argc, const char*[]) {
  auto s = make_value_3_2(argc == 1)   // S(), S(S&&), ~S(), ~S()
}

# don't const non-reference return types (it fallbacks move into a copy operation, longer asm code)
inline const S make_value() {
  return S{};
}
int main() {
  S s;                                 // bad practice
  s = make_value();                    // S(), S(), operator=(const S&), ~S(), ~S()
}
%%


/// gcc: arguments
-std=c++20 -Wall -Wextra -Wconversion -Wshadow -Wpedantic -fsanitize=undefined,address -O3
%%


/// winrt: overridable windows runtime method
unsealed runtimeclass Base {
  overridable void DoSomething();                     // it is automatically made protected
};

// ILSpy metadata:
public class Base : IBase, IBaseOverrides {           // it may be so due to the fact that C# doesn't
  [MethodImpl(MethodImplOptions.InternalCall)]        // have the ability to bypass the derived class
  protected virtual extern string DoSomething();      // from outside the class (base keyword can be
};                                                    // used only from the inside)
%%


/// object orientation
# Object Oriented Programming vs Functional Programming
# https://www.youtube.com/watch?v=wyABTfR9UTU

OOP is not about inheritance, but rather it's about polymorphism.
"I'm sorry that I, long ago, coined the term 'Objects' for this topic, because it gets many people to focus on the lesser idea. The big idea is messaging." — Alan Kay, Object Orientation, 1966

"Object oriented programs are offered as alternatives to correct ones..." — Edsger Dijkstra

however, thing like ADTs are naturally very well formed in terms of class encapsulation/hermetization
%%


/// actor programming: actors
# https://stackoverflow.com/questions/2335337/how-would-you-explain-actors-to-a-non-programmer
# Actors represent simplified people as independent and parallel objects.

Actors are people doing some work inside their houses. In front of each house, there is a mailbox. In order to communicate with each other and get work done, messages are sent between the actors.

* all actors ('objects') act 'at the same time' (concurrently)
* actors don't know what other actors are thinking, but they can send messages (no shared state, copies)
* actors can act on messages (send, receive, ignore)
* actors can create another actor (create, clone)
%%


/// actor programming: messages, message passing
# https://stackoverflow.com/questions/3021650/what-are-messages-in-actor-programming

We have a two actors: Boss and Worker.
Boss SMS Worker and tell him to: 'find the quare root of 2 with precision of 100 digits; reply me at 555-1234 after you have done'
This kind of an instruction is a message

It is a conversation between two people. Both, they can do different things, but they communicate in order.

How is this different from OOP?
* messages are passed asynchronously
* within actor themselves, messages are received and queued synchronously
* information passed in messages are copies, thus there is no shared state

If we really want to make a data shared, then in an actor model we would convert a data into a new actor (man-in-the-middle). Still, there are no problems with synchronization, because receiving messages must be synchronous, thus no read/write actions will be interfering with each other.
%%


/// c++: std::move of trivially-copyable type has no effect
# https://devblogs.microsoft.com/oldnewthing/20220512-00/?p=106651

The language requires merely that a moved-from object be in a legal, albeit unspecified, state.
All RAII types fall into this category, because moving out of an RAII type transfers the responsibility for the resource to the moved-to object.

template<typename T>
constexpr decltype(auto) moe_allow_trivial(T&& t) noexcept {
  return std::move(t); // NOLINT
}
%%


/// functions: tail recursion
# https://stackoverflow.com/questions/33923/what-is-tail-recursion

# Regular recursion: each call pushes an entry onto the call stack; after completion each entry is pop off all the way back down; a large recursive query like that can cause a stack overflow
# Tail recursion: the compiler may be able to collapse the stack down to one entry; in other words, it may be optimized into an iteration; every recursive call must be last call in the instruction chain

factorial(x, fac=1) {                                 // Scheme
  if (x == 1)                                         // base case
    return fac;                                       // after case
  else 
    return factorial(x-1, x*fac);                     // after/recursive case
}

# Heuristic: if it returns an rvalue, then it is not a tail recursion.

public static int factorial(int x) {                  // Java
  if (x == 1) { 
    return 1;                                         // lvalue
  } else {
    return x * factorial(x - 1);                      // last call: operator*
  }
}

public static int tail_factorial(int x, int so_far) {
  if (x == 1) {
    return so_far
  } else {
    return tail_factorial(x - 1, so_far * x);
  }
}


def recsum(x):                                        // Python
  if x == 1:                                          // sum(n) = 0 + 1 + 2 + 3 + 4 + 5 + …
    return x
  else:
    return x + recsum(x - 1)                          // last call: operator+
    
def tailrecsum(x, running_total=0):                   // Python runtime does not support TCO
  if x == 0:                                          // TCO — Tail Call Optimization
    return running_total
  else:
    return tailrecsum(x - 1, running_total + x)
    
    
function recsum(x) {                                  // JavaScript
  if (x === 0) {
    return 0;                                         // recsum(2)
  } else {                                            // 2 + recsum(1)
    return x + recsum(x - 1);                         // 2 + (1 + recsum(0))
  }                                                   // 2 + (1 + 0)
}                                                     // 2 + 1
                                                      // 3
function tailrecsum(x, total = 0) {
  if (x === 0) {
    return total;                                     // tailrecsum(2)
  } else {                                            // tailrecsum(1, 2)
    return tailrecsum(x - 1, total + x);              // tailrecsum(0, 3)
  }                                                   // 3
}
%%


/// testing: test fixtures, test context
# https://stackoverflow.com/questions/12071344/what-are-fixtures-in-programming

The idea: same data, multiple tests.
1) a known state against which a test is running
2) a file containing sample data
3) a process that sets up a required state

One of the most time-consuming parts of writing tests is writing the code to set the world up in a known state and the return it to its original state when the test is complete. This known state is called the fixture of the test.
Automated tests need to be executed many times. To ensure the testing process is repeatable, we would like to run the tests in some known state called fixture.
Typically, each Xamarin.UITest is written as a method that is referred to as a test. The class which contains the test is known as a test fixture.
%%


/// c++: feature testing macros
# https://www.youtube.com/watch?v=4Bf8TmbibXw
# https://en.cppreference.com/w/User:D41D8CD98F/feature_testing_macros
# https://en.cppreference.com/w/cpp/feature_test

#if __cpp_constexpr >= 201304
  #define CONSTEXPR constexpr
#else
  #define CONSTEXPR inline
#endif
%%


/// c++: three-way comparison operator, spaceship operator <=>
# https://devblogs.microsoft.com/oldnewthing/20220516-52/?p=106661
# https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison
# https://en.cppreference.com/w/cpp/named_req/LessThanComparable

possible results: strong ordering, weak ordering, partial ordering
strong ordering: less, equal, equivalent, greater
weak ordering: less, equivalent, greater
partial ordering: less, equivalent, greater, unordered

equal — identical and interchangeable (e.g. "hello", "hello"); a == b
equivalent — not interchangeble but close enough (A is B, when B derives from A); !(a < b) && !(b < a)

std::tuple:
  a < b      :  less
  a > b      :  greater
  otherwise  :  equivalent
  
std::compare_weak_order_fallback:
  a == b     :  equivalent
  a <  b     :  less
  otherwise  :  greater
  

// synthesize a C++20 three-way comparison operator from two-way comparison
std::weak_ordering compare_3way_via_tuple(T const& a, T const& b) 
{
  // std::forward_as_tuple always uses references to its argument
  return std::forward_as_tuple(a) <=> std::forward_as_tuple(b);
}
%%


/// c++: SFINAE (Substitution Failure Is Not An Error)
# https://stackoverflow.com/questions/3407633/explain-c-sfinae-to-a-non-c-programmer
# https://en.cppreference.com/w/cpp/language/sfinae

domain:      template metaprogramming
when:        during overload resolution
what:        substitution of explicitly specified or deduced type for parameter fails
reason:      specialization is discarded from overload set
behaviour:   compile-time error
explanation: parameters substitution occurs twice (before and after argument deduction)
example:     attempting to use a member of a type, where the type does not contain the specified member
keywords:    substitution failure, immediate context
note:        it is not considered to be a programmer fault
solutions: 
    tag dispatch (std::*_iterator_tag), 
    if constexpr, 
    concept, 
    std::enable_if (type traits), 
    static_assert (conditional compile-time errors), 
    std::void_t (partial specialization)


template<typename T>                                       // for all Ts, except specialized ones
constexpr auto is_equal(T a, T b) noexcept {
    return std::cmp_equal(a, b);
}
template<>                                                 // template specialization for T=float
constexpr auto is_equal(float a, float b) noexcept {
    const float eps = 0.001f;                              // we'd like to apply this for every T that is
    return (a >= b - eps) && (a <= b + eps);               // floating point (float, double, long double)
}

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto is_equal(T a, T b) noexcept {
    return std::cmp_equal(a, b);
}
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto is_equal(T a, T b, T eps = 0.001f) noexcept {
    return (a >= b - eps) && (a <= b + eps);
}

template<typename T>
requires std::is_integral_v<T>
constexpr decltype(auto) is_equal(T a, T b) noexcept {
    return std::cmp_equal(a, b);
}
template<typename T>
requires std::is_floating_point_v<T>
constexpr decltype(auto) is_equal(T a, T b, T eps = 0.001f) noexcept {
    return (a >= b - eps) && (a <= b + eps);
}
%%


/// c++: store lvalue or rvalue in the same object
# https://www.fluentcpp.com/2022/05/16/how-to-store-an-lvalue-or-an-rvalue-in-the-same-object/
# https://en.cppreference.com/w/cpp/utility/variant
# https://github.com/USCiLab/cereal/blob/master/include/cereal/details/helpers.hpp#L144-L146

template<typename T, typename V = std::remove_cvref_t<T>>
using value_or_ref = std::variant<V, std::reference_wrapper<V>, std::reference_wrapper<V const>>;

int main() 
{
    constexpr auto onVisit = [](std::string const& s) -> decltype(auto) { 
        std::cout << "visited\n";
        return s; 
    };

    value_or_ref<std::string> str{};
    std::visit(onVisit, str);
    std::cout << std::boolalpha << std::holds_alternative<std::string>(str) << '\n';
    return 0;
}


// 1) if array was passed, keep it as it is
// 2) if reference was passed, store lvalue
// 3) otherwise, copy the value
template<class T>
using Type = typename std::conditional<
    std::is_array<typename std::remove_reference_t<T>::type>::value, 
    typename std::remove_cv<T>::type,
    typename std::conditional<std::is_lvalue_reference<T>::value, T, typename std::decay<T>::type>::type
>::type;
%%


/// c c++: stream
# https://stackoverflow.com/questions/12145357/what-is-a-stream-in-c
# https://stackoverflow.com/questions/38652953/what-does-stream-mean-in-c/52936291#52936291
# https://www.gnu.org/software/libc/manual/html_node/Streams.html

stream — a construct that allows you to send/receive an unknown number of bytes; an idealized flow of data to which the actual input or output is mapped (a water that flows)
pipe/pipeline — a stream chain, a conveyor belt (it's about swimming, not the water)

this is a generic idea
the metaphor relates to a stream of water from a sink/river
it is an abstract interface for triggering input/output flow of data
it is either text or binary
it does not hold any data on itself
from the OS point of view stream is a logical device that connects different devices/sources
are unidirectional by default, except for file streams that are bidirectional
technically, it is a linear queue that connects a file to the program and maintain the flow of data
it is a helper/facilitator, in contrast to the file which is a sequence of bytes

general: does not force any specific implementation, hides low-level details
abstract: represents only the flow of data, not the data itself
uniform: provides the same black-boxed interface to a device/source, e.g. keyboard, printer, socket
linear: data are available through a sequence in time
ideal: can transfer any number of data in any direction, does not care about the data source intrinsics
%%


/// c++: apply permutation
# https://devblogs.microsoft.com/oldnewthing/20170102-00/?p=95095
# https://devblogs.microsoft.com/oldnewthing/20170104-00/?p=95115
# https://devblogs.microsoft.com/oldnewthing/20170109-00/?p=95145
# https://devblogs.microsoft.com/oldnewthing/20170110-00/?p=95155
# https://devblogs.microsoft.com/oldnewthing/20170111-00/?p=95165

template <typename T>
std::vector<T> apply_permutation(const std::vector<T>& v, const std::vector<int>& indices) 
{
    // T is DefaultConstructible
    std::vector<T> result(v.size());
    
    for (std::size_t i = 0; i < v.size(); i++) {
        result[i] = v[indices[i]];
    }  
    
    return result;
}

template <typename T>
std::vector<T> apply_permutation(const std::vector<T>& v, const std::vector<int>& indices) 
{
    // T is CopyConstructible
    std::vector<T> result;
    result.reserve(v.size());
    
    for (std::size_t i = 0; i < v.size(); i++) {
        result.push_back(v[indices[i]]);
    }  
    
    return result;
}

template <typename T>
void apply_permutation(std::vector<T>& v, const std::vector<int>& indices) 
{
    // T is MoveConstructible
    std::vector<T> result;
    result.reserve(v.size());
    
    for (std::size_t i = 0; i < v.size(); i++) {
        result.push_back(std::move(v[indices[i]]));
    }  
    
    v = std::move(result);
}

How to sort a vector really in place, without an additional copy?
Could it be done O(1) or O(N) time?

Naive approach:
     [a, b, c] & [2, 0, 1] → [C, A, B] + hole{value,index}
 (2) [a, b, c] → [C, b, c] and store {a,0}
 (0) [c, b, c] → [c, A, c] and aquire {a,0}, store {b,1}
 (1) [c, a, c] → [c, a, B] and aquire {b,1}

template<typename T>
void apply_permutation(std::vector<T>& v, const std::vector<int>& indices)
{
    using std::swap;                                  // to permit Koenig lookup
    
    for (std::size_t i=0; i<indices.size(); ++i) {    // runs N times
        auto current = i;
        
        while (i != indices[current]) {               // runs at most N times
            auto next = indices[current];
            swap(v[current], v[next]);                // to avoid single-element cycle
            indices[current] = current;               // instead of a sentinel value
            current = next;
        }
                                                      // complexity: O(N)
        indices[current] = current;                   // each item moves at most only once
    }
}

In mathematics, after you've proved something, you should try to strenghten the conclusion and weaken the hypothesis.
Let's acknowledged that T doesn't have to be std::vector, nor we have to apply the full range.

template<typename Iter1, typename Iter2>
void apply_permutation(Iter1 first, Iter1 last, Iter2 indices)
{
    using T = std::iterator_traits<Iter1>::value_type;          // significant for a proxy,
    using U = std::iterator_traits<Iter2>::value_type;          // e.g. std::vector<bool>
    U length = last - first;
    
    for (U i=0; i<length; ++i) {
        U current = i;
        
        if (i != indices[current]) {
            T t{std::move(first[i])};
            
            while (i != indices[current]) {                     // temporarily unstable state
                U next = indices[current];
                first[current] = std::move(first[next]);        // creates a 'hole'
                indices[current] = current;
                current = next;
            }
            
            first[current] = std::move(t);
            indices[current] = current;
        }
    }
}

This permutation application may fail when index value is out of range, or when a value appears more than once.

template<typename Iter1, typename Iter2>
void apply_permutation(Iter1 first, Iter1 last, Iter2 indices)
{
    using std::swap;
    using T = typename std::iterator_traits<Iter1>::value_type;
    using Diff = typename std::iterator_traits<Iter2>::value_type;
    Diff length = std::distance(first, last);
    
    for (Diff i=0; i<length; ++i) {
        Diff current = i;
        
	while (i != indices[current]) {
	    Diff next = indices[current];
	    
	    // in case of an exception [first, last) permute in an unspecified manner,
	    // yet no items will be lost; the same is true for indices argument
	    if (next < 0 || next >= length) {
	        indices[i] = next;
	        throw std::range_error("invalid index in permutation");
	    }
	    
	    if (next == current) {
	        indices[i] = next;
	        throw std::range_error("not a permutation");
	    }
	    
	    swap(first[current], first[next]);
	    indices[current] = current;
	    current = next;
	}

	indices[current] = current;
    }
}

template<typename Iter1, typename Iter2>
void apply_reverse_permutation(Iter1 first, Iter1 last, Iter2 indices)
{
    using std::swap;
    using T = typename std::iterator_traits<Iter1>::value_type;
    using Diff = typename std::iterator_traits<Iter2>::value_type;
    Diff length = std::distance(first, last);
    
    for (Diff i=0; i<length; i++) {
        while (i != indices[i]) {                     // 'working position'
            Diff next = indices[i];
            
            if (next < 0 || next >= length) throw std::range_error("invalid index in permutation");
            if (next == indices[next]) throw std::range_error("not a permutation");
            
            swap(first[i], first[next]);
            swap(indices[i], indices[next]);          // bookkeeping
        }
    }                                                 // complexity: O(N)
}                                                     // each swap moves 1 item, item swaps at most 2x
%%


/// c++: koenig lookup, argument-independent lookup
# https://en.cppreference.com/w/cpp/language/adl
# https://docs.microsoft.com/en-us/cpp/cpp/argument-dependent-name-koenig-lookup-on-functions?view=msvc-170
# https://www.tutorialspoint.com/What-is-Argument-Dependent-Lookup-Koenig-Lookup-in-Cplusplus
# https://newbedev.com/c-operator-lookup-rules-koenig-lookup
# https://stackoverflow.com/questions/40530953/koenig-lookup-for-arguments
# https://stackoverflow.com/questions/4276772/why-was-argument-dependent-lookup-invented?rq=1

In ADL the compiler adds to the overloaded function set the functions which are declared in the namespaces of each parameter.
The compiler can use ADL to find the definition of an unqualified function call.
ADL makes it possible to use operators defined in a different namespace.
ADL was invented to allow the Interface Principle.

namespace ts {
  struct X {};
  void f(const X&) {}
}
int main() {
  ts::X x;                   // compiler finds ts::X
  f(x);                      // unqualified, assuming ts::f because x has been found in ts
}

int main() {
  std::cout << "Test\n";               // inserter operator << is not the global namespace
  operator<<(std::cout, "Test\n");     // the same operation without ADL
}

namespace foo {
  struct bar {};
  bar operator+(const bar& lhs, const bar& rhs);
}
int main() {
  foo::bar b1, b2;
  auto b3 = b1 + b2;                             // with ADL
  auto b4 = foo::operator+(b1, b2);              // without ADL
}

template<typename FwdIt, typename T>
FwdIt remove(FwdIt first, FwdIt last, T const& value) {
  // ADL is the reason behind the established idiom for swapping two objects in generic code:
  using std::swap;
  // because calling std::swap(obj1, obj2) directly would not consider the user-defined swap()
  // functions that could be defined in the same namespace as the types of obj1 or obj2
  
  FwdIt result = first;
  for ( ; first != last; ++first) {
    if (!(*first == value)) swap(*result++, *first);
  }
  return result;
}
%%


/// c++ design: interface principle
# http://www.gotw.ca/publications/mill08.htm
# Herb Sutter, Namespaces and the Interface Principle

For a class X, all functions, including free functions, that both:
   1) 'mention' X, and
   2) are 'supplied with' X
are logically part of X, because they form part of the interface of X.

mention — uses
supplied with — supplied in the same header or namespace with


namespace n {                                    // operator+ is 'supplied with' class C
  class C {};
  int operator+(int i, n::C) { return i+1; }     // operator+ 'mention' class C
}
int main() {
  n::C a[10];
  std::accumulate(a, a+10, 0);                   // ADL follows n::operator+
}

namespace n { 
  class C {};
}
int operator+(int i, n::C) { return i+1; } 
int main() {
  n::C a[10];
  std::accumulate(a, a+10, 0);                   // doesn't guarantee to compile
}
%%


/// c++: sorting by indices with caching, Schwartzian transform, decorate-sort-undecorate
# https://devblogs.microsoft.com/oldnewthing/20170105-00/?p=95125
# https://devblogs.microsoft.com/oldnewthing/20170106-00/?p=95135
# https://en.wikipedia.org/wiki/Schwartzian_transform

For now, the idea is to: 
  1) designate valid indices (sorted state), and 
  2) apply permutation on the source (to avoid expensive copies in the first place).


template<typename Iter, typename Compare>
void sort_minimize_copies(Iter first, Iter last, Compare cmp)
{
  using Diff = typename std::iterator_traits<Iter1>::difference_type;
  Diff length = std::distance(first, last);
  std::vector<Diff> indices(length);
  std::iota(indices.begin(), indices.end(), static_cast<Diff>(0));
  std::sort(indices.begin(), indices.end(), [&](Diff a, Diff b) { return cmp(first[a], first[b]); });
  apply_permutation(first, last, indices.begin());
}

template<typename Iter>
void sort_minimize_copies(Iter first, Iter last)
{
  return sort_minimize_copies(first, last, std::less<>());
}


The general idea of sorting is to use keys. Each item provides a key that is being compared with the other one via a comparator.

constexpr auto key = [](const Person& p){ return p.lastname; };
sort_by(persons, key(), std::less<std::string>);
// compare_result [&](T& a, T& b) -> return comparator(key(a), key(b))


The idea of a Schwartzian transform is to avoid recomputing the sorting keys (memoize them).
This idiom has been demonstrated by Randal L. Schwartz in Perl 5 in 1994.
                                                    
                                       ["c++", "c", "c#"]                      lexicographically
  1) merge each item with its key      ("c++", 3), ("c", 1), ("c#", 2)         decorate
  2) sort by the key                   ("c", 1), ("c#", 2), ("c++", 3)         sort
  3) throw away the keys               "c", "c#", "c++"                        undecorate

template<typename Iter, typename UnaryOperation, typename Compare>
void sort_by_with_caching(Iter first, Iter last, UnaryOperation op, Compare comp)
{
  using Diff = typename std::iterator_traits<Iter>::difference_type;
  using T =  typename std::iterator_traits<Iter>::value_type;
  using Key = decltype(op(std::declval<T>()));
  using Pair = std::pair<T, Key>;
  Diff length = std::distance(first, last);
  
  std::vector<Pair> pairs;
  pairs.reserve(length);
  
  constexpr auto onDecorate = [&](T& t) {
      return std::make_pair(std::move(t), op(t));
  };
  constexpr auto onSort = [&](const Pair& a, const Pair& b) {
      return comp(a.second, b.second);
  };
  constexpr auto onUndecorate = [](Pair& p) {
      return std::move(p.first);
  };
  
  std::transform(first, last, std::back_inserter(pairs), onDecorate);
  std::ranges::sort(pairs, onSort);
  std::ranges::transform(pairs, first, onUndecorate);
}


template<typename Iter, typename UnaryOperation, typename Compare>
void sort_by_with_caching(Iter first, Iter last, UnaryOperation op, Compare comp)
{
  using Diff = typename std::iterator_traits<Iter>::difference_type;
  using T =  typename std::iterator_traits<Iter>::value_type;
  using Key = decltype(op(std::declval<T>()));
  using Pair = std::pair<T, Key>;
  
  Diff length = std::distance(first, last);  
  std::vector<Key> keys;
  keys.reserve(length);
  std::transform(first, last, std::back_inserter(keys), [&](T& t) { return op(t); });

  std::vector<Diff> indices(length);
  std::iota(indices.begin(), indices.end(), static_cast<Diff>(0));
  std::ranges::sort(pairs, [&](Diff a, Diff b) { return comp(keys[a], keys[b]); });

  apply_permutation(first, last, indices.begin());
}

template<typename Iter, typename UnaryOperation>
void sort_by_with_caching(Iter first, Iter last, UnaryOperation op)
{
  sort_by_with_caching(first, last, op, std::less<>());
}
%%


/// c++: storage duration vs lifetime
# https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name

lifetime — time when objects are usable (runtime property)
storage duration — the minimum potential lifetime of the storage containing the objects (rules)

1) automatic storage duration          allocation/deallocation at code block start/end
2) static storage duration             allocation/deallocation at program start/end
3) dynamic storage duration            allocation/deallocation upon request
4) thread_local storage duration       allocation/deallocation at thread begin/end
%%


/// c++: translation unit, tu
# http://web.archive.org/web/20090427201018/http://efnetcpp.org/wiki/Translation_unit

TU — 'translated' source code, may or may be not a C++ program

A translation unit is the basic unit of compilation in C++. It consists of the contents of a single source file, plus the contents of any header files directly or indirectly included by it, minus those lines that were ignored using conditional preprocessing statements.
A single translation unit can be compiled into an object file, library, or executable program.
The notion of a translation unit is most often mentioned in the contexts of the One Definition Rule, and templates.
%%


/// c++: linkage
# https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name

Linkage refers to translation unit (TU) and One Definition Rule (ODR).

                             name can be referred to:
1) no linkage                only from the scope of its creation
2) internal linkage          from all scopes in the current TU
3) external linkage          from the scopes of another TU
4) module linkage            from the same module unit only
%%


/// c++: function-try-block
# https://en.cppreference.com/w/cpp/language/function-try-block
# https://stackoverflow.com/questions/8359635/what-is-the-purpose-of-a-function-try-block

It is an alternative syntax of a function body.
Before any catch clauses of a function-try-block on a constructor are entered, all fully-constructed members and bases have already been destroyed.
The primary purpose of function-try-blocks is to respond to an exception thrown from the member initializer list in a constructor by rethrowing.

struct S {
  std::string member;
  
  S(const std::string& str, int index) try : member(str, index) {
    std::cout << "S(" << str << ", " << index << ")";
  }
  catch (const std::exception& e) {
    std::cout << e.what() << '\n';
  }                                              // implicit throw here
};

int main() 
{
  S s{"abc", 1};                                 // does not throw
}


class Animals {
    class Cat* cat;
    class Dog dog;
    
  public:
    Animals() : cat(new Cat), dog() {            // if Dog() throws, the cat will leak memory
      std::cout << "Animals()\n";                // Animals() ctor is never completed then, thus
    }                                            // it does not hold its destructor
    
    Animals() try : cat(new Cat), dog() {
      std::cout << "Animals() try\n";
    }
    catch (...) {
      delete cat;
      throw;                                     // each catch clause must throw, either
    }                                            // directly or indirectly
    
    ~Animals() {
      delete cat;
      cat = NULL;
      std::cout << "~Animals()\n";
    }
};
%%


/// windows: ltr/rtl layout, left-to-right/right-to-left layout for windows
# https://devblogs.microsoft.com/oldnewthing/20220523-00/?p=106680

int GetLanguageReadingLayout(PCWSTR languageName)
{
  // 0 = left to right, e.g. English
  // 1 = right to left, e.g. Arabic
  // 2 = top to bottom, right to left, e.g. classical Chinese
  // 3 = top to bottom, left to right, e.g. Mongolian
  int direction = 0;
  
  THROW_IF_WIN32_BOOL_FALSE(GetLocaleInfoEx(
      languageName, 
      LOCALE_IREADINGLAYOUT | LOCALE_RETURN_NUMBER,
      reinterpret_cast<LPWSTR>(&direction),
      sizeof(direction) / sizeof(wchar_t)
  ));
  return direction;
}

int GetSystemDefaultLanguageReadingLayout()  
{
  return GetLanguageReadingLayout(LOCALE_NAME_SYSTEM_DEFAULT);
}

int GetUserDefaultLanguageReadingLayout()
{
  return GetLanguageReadingLayout(LOCALE_NAME_USER_DEFAULT);
}


namespace wil {
  template<typename string_type, size_t nStackBuffer = 40>
  HRESULT GetThreadPreferredUILanguages(DWORD flags, _Out_ PULONG nLangs, string_type& result)
  {
    wchar_t stackBuffer[nStackBuffer];
    ULONG required = ARRAYSIZE(stackBuffer);
    
    // 1. the list of applicable languages can change asynchronously
    // 2. wil assumes null-terminated strings, doesn't support double-null-terminated strings
    if (::GetThreadPrefferedUILanguages(flags, nLangs, stackBuffer, &required)) {
      result = make_unique_string_nothrow<string_type>(nullptr, required);
      RETURN_IF_NULL_ALLOC(result);
      memcpy(result.get(), stackBuffer, required * sizeof(wchar_t));
      return S_OK;
    }
    
    DWORD error = ::GetLastError();
    
    while (error == ERROR_INSUFFICIENT_BUFFER) {
      result = make_unique_string_nothrow<string_type>(nullptr, required);
      RETURN_IF_NULL_ALLOC(result);
      
      if (::GetThreadPrefferedUILanguages(flags, nLangs, result.get(), &required))
        return S_OK;
      
      error = ::GetLastError();
    }
    
    RETURN_WIN32(error);
  }
  
  template<typename string_type = wil::unique_cotaskmem_string, size_t nStackBuffer = 40>
  string_type GetThreadPrefferedUILanguages(DWORD flags, _Out_ PULONG nLangs, )
  {
    string_type result;
    THROW_IF_FAILED((wil::GetThreadPrefferedUILanguages<string_type, nStackBuffer>(flags, nLangs, result)));
    return result;
  }
}

int GetDefaultThreadLanguageReadingLayout()
{
  ULONG count;
  return GetLanguageReadingLayout(
      wil::GetThreadPrefferedUILanguages(MUI_LANGUAGE_NAME | MUI_MERGE_UI_FALLBACK, &count).get()
  );
}
%%


/// c c++: signals
# https://www.javatpoint.com/cpp-signal-handling
# https://en.wikipedia.org/wiki/C_signal_handling
# https://pl.wikipedia.org/wiki/Komunikacja_mi%C4%99dzyprocesowa

Signals are used to report some exceptional behaviour (SIGABRT, SIGFPE, SIGILL, SIGINT, SIGSEGV, SIGTERM, SIGTRAP) or asynchronous event outside the program (especially keyboard interaction). In some operating systems they are known as system interrupts.


#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

static void catch_function(int signo) {
  puts("signal caught");
}

int main(void) {
  if (signal(SIGINT, catch_function) == SIG_ERR) {
    fputs("signal handler error");
    return EXIT_FAILURE;
  }

  if (raise(SIGINT) != 0) {
    fputs("signal raising error");
    return EXIT_FAILURE;
  }

  fputs("signal sent");
  return EXIT_SUCCESS;
}


#include <csignal>
#include <iostream>

std::sig_atomic_t sig_value = 0;

void handler(int sig) { sig_value = sig; }

int main() {
  signal(SIGABRT, handler);
  raise(SIGABRT);
  std::cout << sig_value << std::endl;
  return 0;
}
%%


/// c++: covariant return types
# https://stackoverflow.com/questions/1260757/when-is-c-covariance-the-best-solution

Used in: clone() methods (Prototype pattern), concrete Factories implementations.

struct A {
  virtual ~A() noexcept;
  virtual A* f();                 // type A*, base class
};
struct B : public A {
  virtual B* f();                 // type B*, derived class, covariant return type
};

class Factory {
  public:
    virtual product* create() const = 0;
};
class ConcreteFactory : public Factory {
  public:
    virtual ConcreteProduct* create() const {
        return new ConcreteProduct();
    };
};
%%


/// winrt c++: convert between windows filetime and unix time_t
# https://devblogs.microsoft.com/oldnewthing/20220602-00/?p=106706

Windows tracks time in 100 ns units since January 1, 1601 (FILETIME).
Unix tracks time in 1 s units since January 1, 1970 (time_t).
Converting between those two requires a magic number 116444736000000000 (std::chrono::time_point).


auto unixtime = winrt::clock::from_time_t(unix_time_seconds);
FILETIME filetime = winrt::clock::to_file_time(unixtime);

auto datetime = winrt::clock::from_file_time(filetime);
time_t unix_time_seconds = winrt::clock::to_time_t(datetime);

auto datetime = winrt::clock::from_file_time(filetime);
datetime += 3min;
time_t unix_time_seconds = winrt::clock::to_time_t(datetime);

auto timet_to_sysseconds = std::chrono::sys_seconds(std::chrono::seconds(N));
auto sysseconds_to_timet = seconds.time_since_epoch().count();
auto systime_to_winrt = winrt::clock::from_sys(sys);
auto winrt_to_systime = winrt::clock::to_sys(winrt);
%%


/// c++: unique_ptr, shared_ptr, weak_ptr
# https://www.sandordargo.com/blog/2022/06/08/smart-pointers-and-deleters
# https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful
# https://cplusplus.com/reference/memory/weak_ptr/weak_ptr/


  Logger     Logger                    std::unique_ptr
    ↑          ↑                       independent object, pointer ownership
 Keyboard    Screen
 
        Logger                         std::shared_ptr
        ↑    ↑                         object in relation to others, shared resource pointer
 Keyboard    Screen
 
        Logger                         std::weak_ptr
        ↑    ↑ ↓                       indirect access to an object, cyclic dependency pointer
 Keyboard    Screen                    (3)
 
(3) both Screen and Keyboard has a shared pointer to the Logger;
if we use a raw pointer or std::unique_ptr and then Screen gets destroyed:
 * Logger will be still alive and have a dangling pointer to the Screen
 * Keyboard still has shared ownership
if we use a shared pointer and then Screen gets destroyed:
 * pointers cannot be destroyed because of a cyclic dependency between them
if we use a weak pointer and the Screen gets destroyed:
 * there will be still a dangling pointer Logger→Screen, yet it'll be detected later via expired()/lock()
 

weak_ptr use cases: 
 * to break cyclic dependency (circular references), to resolve the dangling pointer issue
 * to break cycle in data structures per se, e.g. in a linked list
 * in asynchronous data structures for access purposes, e.g. vector<weak_ptr<Task>>
 * in conjunction with shared_from_this() idiom
 * to check the correct deletion of an object, especially in a unit test
 * to manage cache validity


std::unique_ptr<int, FakeDeleter<int>> upFD (new int(42), FakeDeleter<int>());
std::unique_ptr<int, FakeDeleter<int>> upFD2 (new int(51), FakeDeleter<int>());
std::unique_ptr<int, LoggingDeleter<int>> upLD (new int(42), LoggingDeleter<int>());
upFD = std::move(upFD2); // OK
upFD = std::move(upLD); // NOT OK, fails to compile!

std::shared_ptr<int> spFD (new int(51), FakeDeleter<int>());
std::shared_ptr<int> spFD2 (new int(51), FakeDeleter<int>());
std::shared_ptr<int> spLD (new int(51), LoggingDeleter<int>());
spFD = spFD2;
spFD = spLD;

std::shared_ptr<int> sp (new int);       // weak count:
std::weak_ptr<int> wp1;                  // wp1.use_count() == 0
std::weak_ptr<int> wp2 (wp1);            // wp2.use_count() == 0
std::weak_ptr<int> wp3 (sp);             // wp3.use_count() == 1
%%


/// windows clipboard: clipboard ownership, clipboard delay-rendering
# https://devblogs.microsoft.com/oldnewthing/20220608-00/?p=106727
# https://devblogs.microsoft.com/oldnewthing/20210526-00/?p=105252
# https://devblogs.microsoft.com/oldnewthing/20220609-00/?p=106731

On Windows a clipboard can be used:
* via taking an ownership over it,
* via delayed rendering (producing the data later).

Ownership of the clipboard changes as follows:
* When Empty­Clipboard() is called, the current clipboard opener becomes the clipboard owner.
* When the clipboard owner is destroyed, the clipboard owner resets to null.

There are two ways to make clipboard data available. One is to put the data directly on the clipboard at the time you take ownership of it. Another option is to declare that you have data of a particular type, but instead of putting the data on the clipboard, you say, “If anybody asks, let me know, and I’ll produce the data.” This is known as clipboard delay-rendering, and it is a common optimization for data formats that are rarely used or expensive to produce. If somebody asks for the format, the clipboard owner gets a WM_RENDER­FORMAT message to say, “Somebody wants that data, can you produce it now?”
When the system asks a clipboard owner to render clipboard data, it sends the WM_RENDER­FORMAT message and waits up to 30 seconds for it to return. If the clipboard owner fails to produce the data within 30 seconds, then system abandons the request, and Get­Clipboard­Data returns NULL.


How to wait for a delayed-rendered clipboard more than 30 seconds?
void workaround() 
{
  if (OpenClipboard(hwnd)) {
    auto data = GetClipboardData(format);
    
    if (!data) {
      auto owner = GetClipboardOwner();
      SendMessage(owner, WM_NULL, 0, 0);
      data = GetClipboardData(format);
    }
    
    if (data) {
      // yay, we have clipboard data
    }
  }
  
  CloseClipboard();
}
%%


/// linux clipboard: primary selection, secondary selection, clipboard selection
# https://tronche.com/gui/x/icccm/sec-2.html#s-2.6.1
# https://en.wikipedia.org/wiki/X_Window_selection
# https://unix.stackexchange.com/questions/139191/whats-the-difference-between-primary-selection-and-clipboard-buffer

On Linux using a clipboard is standardized by an ICCM as a part of X Window System.

X Consortium Standard, Selection Atoms/X Atoms, Inter-Client Communication Conventions Manual:
* PRIMARY: for single-argument commands, e.g. in terminals (without explicit copy action)
* SECONDARY: for second argument in 2-arg commands
* CLIPBOARD: to hold data that is being transferred between clients (cut, copied, pasted)

echo primary | xclip -sel p       # Ctrl + Shift + v: clipboard
echo secondary | xclip -sel p     # Middle click: primary
echo clipboard | xclip -sel c     # Paste selection: (Shift + Insert): primary
%%


/// testing: general approach
# https://www.youtube.com/watch?v=SQUI9Ixb790
# Continuous Delivery, The Most Common Test Driven Development Mistakes

Aim to test:
 * contracts and outcome, not the code itself to obtain more code coverage
 * validity and design (does what we think? is design good?)
 * interfaces, not the implementation details
%%


/// software build: mono-repo vs multi-repo
# https://www.youtube.com/watch?v=bWZVx6TgVvc
# Continuous Delivery, The Monolith vs Microservices Debate

mono-repo: one big repository for system
multi-repo: system divided into smaller pieces
 * microservices: each repo is decoupled (scalable approach to build software)
 * coupled-modules: each repo may interact with other repos (preserve relations, test multi-repo)
%%


/// software: domain knowledge
# https://softwareengineering.stackexchange.com/questions/114484/domain-knowledge-vs-programming

# https://www.youtube.com/watch?v=fx-Ne_s71iY
# Continuous Delivery, A Guide To Refactoring In TDD


”domain knowledge is something related to are you are working in”
”A programmer does not need domain knowledge. (...) It means I can work anywhere, and never be sidetracked into work I don't want to do.”
”Domain knowledge is good but this is not the responsibility of the programmer. It is the responsibility of business analyst, systems analyst, data modeler, software testers, software architects and sometimes the project manager. (...) Also, programming is not a light skill to acquire and maintain. For example, You can't expect someone to know banking compliance rules, regulations, and OOP.”


# You can read this and understand what it doing without any additional knowledge.
private int addDenominator(Fraction that)
{
  int denominator = this.denominator;
  
  if (this.denominator != that.denominator)
    denominator = this.denominator * that.denominator;
    
  return denominator;
}

# Here, you may need to need that are things called parameters and they sometimes need decoding,
# and that we can store multiple groups of parameters in arrays.
public static ParamDecoder getDecoder(Class type)
{
  try
  {
    if (type.isArray())
      return getParamDecoder(arrayDecoders, type.getComponentType(), ObjectArrayParamDecoder::new);
      
    return getParamDecoder(decoders, type, ObjectParamDecoder::new);
  }
  catch (Exception ignored)
  {
    throw new ReactInitialisationException("Type not found for parameter decoding");
  }
}
%%


/// management: stream-aligned teams, team topology
# Matthew Skelton, Manuel Pais, Team Topologies

# https://www.youtube.com/watch?v=pw686Oyeqmw
#  Continuous Delivery, Why Your Software Team CAN’T Scale


”Any organization that designs a system will produce a design whose structure is a copy of the orginization's communication structure.” — Melvin E. Conway

Funtional Teams: align teams with bounded contexts
Stream-Aligned Teams: ”A stream is a continuous flow of work aligned to a business domain or organisational copability. (...) A stream aligned team is aligned with a single valuable stream of work. (...) A stream aligned team has minimal (ideally zero) hand-offs of work to other teams.”

Capabilities of a stream aligned team:
 * app security
 * commercial and operational viability analysis
 * design and architecture
 * development and coding
 * infrastructure ad operability
 * metrics and monitoring
 * product management and ownership
 * testing and quality assurance
 * user experience UX
 
Enabling Teams: helps stream-aligned teams acquire missing capabilities
Complicated Subsystem Teams: reduce the cognitive load of stream-aligned teams

Example of complicated subsystem team artifact: LMAX Disruptor.
%%


/// concurrency design: lmax disruptor
# https://lmax-exchange.github.io/disruptor/
# https://lmax-exchange.github.io/disruptor/disruptor.html
# "LMAX Disruptor: High performance alternative to bounded queues for exchanging data between concurrent threads" | Martin Thompson, Dave Farley, Michael Barker, Patricia Gee, Andrew Stewart

”The Disruptor is the result of our research and testing. We found that cache misses at the CPU-level, and locks requiring kernel arbitration are both extremely costly, so we created a framework which has "mechanical sympathy" for the hardware it’s running on, and that’s lock-free.”
Those concurrency issues are inclined to Java.

”Locks are incredibly expensive because they require arbitration when contended. This arbitration is achieved by a context switch to the operating system kernel which will suspend threads waiting on a lock until it is released. During such a context switch, as well as releasing control to the operating system which may decide to do other house-keeping tasks while it has control, execution context can lose previously cached data and instructions. This can have a serious performance impact on modern processors.”
To LMAX, every usual solution were to slow. That include CAS, memory barriers, cache lines solutions, contended queue implementations, cost of pipelines and graphs units of work.

”While trying to address the problems described above, a design emerged through a rigorous separation of the concerns that we saw as being conflated in queues. This approach was combined with a focus on ensuring that any data should be owned by only one thread for write access, therefore eliminating write contention. That design became known as the “Disruptor”. It was so named because it had elements of similarity for dealing with graphs of dependencies to the concept of “Phasers” in Java 7, introduced to support Fork-Join.”

Design of Disruptor concerns at:
 * memory allocation (ring-buffer, value types in Java, GC for low-latency system, queue-based system)
 * teasing apart the concerns (storage, producers, consumers)
 * sequencing (producer/consumer interacts with the ring buffer through cursors in a sequence)
 * batching effect (lagging consumer quickly regaining pace with cursors and ring buffer)
 * dependency graphs (single ring buffer instead)
 * throughput performance (measuring)

                     
                                          .-------------- IProducerBarrier --------------- .
 IEntryFactory   ← -------------------.   |                                                |
      ↓                               |   ↓                                                ↓
    IEntry  ← ------------------- * RingBuffer ← --------- IConsumerBarrier ← -------- IConsumer
                                        *   *                     |                        ↑
                                        |   |                     .------------------------.
      IClaimStrategy ← -----------------.   .----------.
          ↑                                            |
          |                                            .- → IWaitStrategy
          .------- SingleThreadedClaimStrategy                ↑
          .------- MultiThreadedClaimStrategy                 .------ BusySpinWaitStrategy
                                                              .------ YieldingWaitStrategy
                                                              .------ BlockingWaitStrategy


interface ProducerBarrier<ValueEntry> {
  public ValueEntry nextEntry();
  public void commit(ValueEntry);
};

class RingBuffer<ValueEntry> {
  public ConsumerBarrier<ValueEntry> createConsumerBarrier();
  public ProducerBarrier<ValueEntry> createProducerBarrier(BatchConsumer<ValueEntry>);
};

final BatchHandler<ValueEntry> batchHandler = new BatchHandler<ValueEntry>() { // for consumers
  public void onAvailable(final ValueEntry entry) throws Exception;
  public void onEndOfBatch() throws Exception;
  public void onCompletion();
};

RingBuffer<ValueEntry> ringBuffer = new RingBuffer<>(ENTRY_FACTORY, SIZE, SINGLE_THREADED, YIELDING);
ConsumerBarrier<ValueEntry> consumerBarrier = ringBuffer.createConsumerBarrier();
BatchConsumer<ValueEntry> batchConsumer = new BatchConsumer<ValueEntry>(consumerBarrier, batchHandler);
ProducerBarrier<ValueEntry> producerBarrier = ringBuffer.createProducerBarrier(batchConsumer);

EXECUTOR.submit(batchConsumer);                       // separate thread per consumer
ValueEntry entry = producerBarrier.nextEntry();       // claim entry in a sequence
copyDataIntoTheEntryContainer();
producerBarrier.commit(entry);                        // make the entry available to consumers


Does it make even sense in C++?
 * why not to use Active objects with claiming/waiting interface?
 * why not to use actor programming/message passing with message queues?
%%


/// devops measurement: dora metrics
# https://cloud.google.com/blog/products/devops-sre/another-way-to-gauge-your-devops-performance-according-to-dora
# https://storage.googleapis.com/gweb-cloudblog-publish/images/1_breaking_down_devops_perf.max-2800x2800.jpg
# https://www.leanix.net/en/wiki/vsm/dora-metrics
# https://www.splunk.com/en_us/data-insider/devops-research-and-assessment-metrics.html

# Continuous Delivery, "How To Measure Software Delivery Using DORA Metrics"
# https://www.youtube.com/watch?v=hbeyCECbLhk


DORA metrics are used by DevOps teams to measure their performance and find out whether they are “low performers” to “elite performers”.
DORA metrics were defined by Google Cloud’s DevOps Research and Assessments team based on six years of research into the DevOps practices of 31,000 engineering professionals. The DORA framework uses the four key metrics outlined below to measure two core areas of DevOps: speed and stability.

DF       deployment frequency          frequency of successful software releases
LT       lead time for changes         time between a code change commit and its deployable state
MTTR     mean time to recovery         time between an interruption/system failure and full recovery
CFR      change failure rate           how often a team’s changes/hotfixes lead to failures


How often does your organization deploy code to production or release it to end-users?
Elite performers:   On-demand (multiple deployments per day)
High performers:    Between once per day and once per week
Medium performers:  Between once per week and once per month
Low performers:     Between once per month and once every six months

How long does it take to go from code committed to code successfully running in production?
Elite performers:   Less than one day
High performers:    Between one day and one week
Medium performers:  Between one week and one month
Low performers:     Between one month and six months

What percentage of changes to production or end-users results in degraded service?
Elite performers:   0-15%
High performers:    0-15%
Medium performers:  0-15%
Low performers:     46-60%

How long does it take to restore service when a service incident or a defect that impacts users occur?
Elite performers:   Less than an hour
High performers:    Less than one day
Medium performers:  Less than one day
Low performers:     Between one week and one month


What are the benefits and challenges of DORA metrics?
 * better decision making
 * greater value
 * continuous improvement
%%


/// devops measurement: flow metrics
# https://www.splunk.com/en_us/data-insider/devops-research-and-assessment-metrics.html
# https://www.scaledagileframework.com/value-streams/
# https://en.wikipedia.org/wiki/Value_stream

Value Streams represent the series of steps that an organization uses to implement Solutions that provide a continuous flow of value to a customer.
A value stream is the set of actions that take place to add value to a customer from the initial request through realization of value by the customer.

Flow metrics are a framework for measuring how much value is being delivered by a product value stream and the rate at which it is delivered from start to finish. While traditional performance metrics focus on specific processes and tasks, flow metrics measure the end-to-end flow of business and its results.

flow velocity      the number of flow items completed over a period (acceleration)
flow time          how much time has elapsed between the start and finish of a flow item
flow efficiency    the ratio of active time to total flow time (waste in the value stream)
flow load          the number of flow items in a value stream (utilization of value stream)
%%


/// c++ concepts: object concepts
# https://github.com/QuantlabFinancial/cpp_tip_of_the_week/blob/master/282.md

struct movable {
  constexpr movable(movable&&) = default;
  constexpr auto operator=(movable &&) -> movable & = default;
};

static_assert(std::movable<movable>)
%%


/// winrt: apartments, com marshaling, agile reference, marshaller
# https://devblogs.microsoft.com/oldnewthing/20220614-00/?p=106750
# https://devblogs.microsoft.com/oldnewthing/20220616-00/?p=106757
# https://devblogs.microsoft.com/oldnewthing/20220617-41/?p=106760
# https://devblogs.microsoft.com/oldnewthing/20220621-00/?p=106767
# https://devblogs.microsoft.com/oldnewthing/20220622-00/?p=106774
# https://devblogs.microsoft.com/oldnewthing/20220623-00/?p=106778

COM organizes threads into apartments. All the thread in an apartment have access to the same objects, and if you want to grant access to another apartment, you have to do it by a mechanism known as marshaling.
The easiest way to marshal an object’s interface is to ask somebody else to manage it for you: The Ro­Get­Agile­Reference function creates a new object that represents an agile reference to the original object. In COM, the term agile means that it can be used in any apartment. You can then ask that agile reference to resolve a reference to the original interface, and it will give you an object which you can use from the apartment doing the resolving.


struct CompoundMarshalerByCopy : public IMarshal {
    IntPtr m_value = nullptr;
    
    // QueryInterface + AddRef + Release
    
    IUnknown* CastToUnknown()
    {
        return static_cast<IMarshal*>(this);
    }
    
    bool ShouldMarshalByValue(DWORD dwDestCtx)
    {
        return dwDestCtx == MSHCTX_CROSSCTX || dwDestCtx == MSHCTX_INPROC || dwDestCtx == MSHCTX_LOCAL || dwDestCtx == MSHCTX_NOSHAREDMEM;
    }
    
    STDMETHODIMP GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestCtx, void* pvDestCtx, DWORD mshlflags, CLSID* clsid)
    {
        if (ShouldMarshalByValue(dwDestCtx)) {
            *clsid = CLSID_Marshaller;
            return S_OK;
        }
    
        ComPtr<IMarshal> marshal;
        RETURN_IF_FAILED(CoGetStandardMarshal(riid, CastToUnknown(), dwDestCtx, pvDestCtx, mshlflags, &marshal));
        RETURN_IF_FAILED(marshal->GetUnmarshalClass(riid, pv, dwDestCtx, pvDestCtx, mshlflags, clsid));
        return S_OK;
    }
    
    STDMETHODIMP GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestCtx, void* pvDestCtx, DWORD mshlflags, LPDWORD size)
    {
        if (ShouldMarshalByValue(dwDestCtx)) {
            *size = sizeof(m_value);
            return S_OK;
        }
        
        ComPtr<IMarshal> marshal;
        RETURN_IF_FAILED(CoGetStandardMarshal(riid, CastToUnknown(), dwDestCtx, pvDestCtx, mshlflags, &marshal));
        RETURN_IF_FAILED(marshal->GetMarshalSizeMax(riid, pv, dwDestCtx, pvDestCtx, mshlflags, size));
        return S_OK;
    }
    
    STDMETHODIMP MarshalInterface(IStream* pstm, REFIID riid, void* pv, DWORD dwDestCtx, void* pvDestCtx, DWORD mshlflags)
    {
        if (ShouldMarshalByValue(dwDestCtx)) {
            RETURN_IF_FAILED(pstm->Write(&m_value, sizeof(m_value), nullptr));
            return S_OK;
        }
        
        ComPtr<IMarshal> marshal;
        RETURN_IF_FAILED(CoGetStandardMarshal(riid, CastToUnknown(), dwDestCtx, pvDestCtx, mshlflags, &marshal));
        RETURN_IF_FAILED(marshal->MarshalInterface(pstm, riid, pv, dwDestCtx, pvDestCtx, mshlflags));
        return S_OK;
    }
    
    STDMETHODIMP UnmarshalInterface(IStream* pstm, REFIID riid, void* ppv)
    {
        *ppv = nullptr;
        ULONG actual;
        RETURN_IF_FAILED(pstm->Read(&m_value, sizeof(m_value), &actual));
        RETURN_HR_IF(E_FAIL, actual != sizeof(m_value));
        return QueryInterface(riid, ppv);
    }
    
    STDMETHODIMP ReleaseMarshalData(IStream* pstm)
    {
        RETURN_IF_FAILED(pstm->Seek({sizeof(m_value), 0}, STREAM_SEEK_CUR, nullptr));
        return S_OK;
    }
    
    STDMETHODIMP DisconnectObject(DWORD dwReserved)
    {
        return E_UNEXPECTED;
    }
};


class CompoundMarshalerByShallowCopy : public IMarshal {
  private: 
    int32_t m_value;
    ComPtr<IThing> thing;
    
  public:
    // QueryInterface, AddRef, Release, ...
    
    STDMETHODIMP GetMarshalSizeMax(...) {
      if (ShouldMarshalByValue(dwDestCtx)) {
        DWORD sThing;
        RETURN_IF_FAILED(CoGetMarshalSizeMax(&sThing, __uuidof(thing.Get()), thing.dwDestCtx, ...));
        *size = sizeof(m_value) + sThing;
        return S_OK;
      }
      // ditto
    }
    
    STDMETHODIMP MarshalInterface(...) {
      if (ShouldMarshalByValue(dwDestCtx)) {
        RETURN_IF_FAILED(pstm->Write(&m_value, sizeof(m_value), nullptr));
        return CoMarshalInterface(pstm, __uuidof(thing.Get()), thing.Get(), ...);
      }
      // ditto
    }
    
    STDMETHODIMP UnmarshalInterface(...) {
      // ditto
      RETURN_IF_FAILED(CoUnmarshalInterface(IID_PPV_ARGS(&thing)));
      return QueryInterface(riid, ppv);
    }
    
    STDMETHODIMP ReleaseMarshalData(...) {
      // ditto
      RETURN_IF_FAILED(CoReleaseMarshalData(pstm));
      return S_OK;
    }
};


struct FreeThreadedMarshaler : public IMarshal {
  bool CanUseFreeThreadedMarshaler(DWORD dwDestCtx, DWORD mflags) {
    return (dwDestCtx == MSHCTX_INPROC || dwDestCtx == MSHCTX_CROSSCTX) &&
    (mflags == MSHLFLAGS_NORMAL || mflags == MSHLFLAGS_TABLESTRONG || mflags == MSHLFLAGS_TABLEWEAK);
  }
  
  STDMETHODIMP GetUnmarshalClass(...) {
    if (CanUseFreeThreadedMarshaler(dwDestCtx)) {
      *clsid = CLSID_FreeThreadedUnmarshaler;
      return S_OK;
    }
    // ditto
  }
  
  STDMETHODIMP GetMarshalSizeMax(...) {
    if (CanUseFreeThreadedMarshaler(dwDestCtx, mshlflags)) {
      *size = sizeof(mshlflags) + sizeof(void*);
      return S_OK;
    }
    // ditto
  }
  
  STDMETHODIMP MarshalInterface(...) {
    if (CanUseFreeThreadedMarshaler(dwDestCtx, mshlflags)) {
      RETURN_IF_FAILED(pstm->Write(&mshlflags, sizeof(mshlflags), nullptr));
      RETURN_IF_FAILED(pstm->Write(&pv, sizeof(pv), nullptr));
      if (mshlflags != MSHLFLAGS_TABLEWEAK) ((*IUnknown)pv)->AddRef();
      return S_OK;
    }
    // ditto
  }
  
  STDMETHODIMP UnmarshalInterface(...) {
    *ppv = nullptr;
    ULONG actual;
    DWORD mshlflags;
    RETURN_IF_FAILED(pstm->Read(&mshlflags, sizeof(mshlflags)), &actual);
    RETURN_HR_IF(E_FAIL, actual != sizeof(mshlflags));
    IUnknown* punk;
    RETURN_IF_FAILED(pstm->Read(&punk, sizeof(punk), &actual));
    RETURN_HR_IF(E_FAIL, actual != sizeof(punk));
    if (mshlflags != MSHLFLAGS_NORMAL) punk->AddRef();
    *ppv = punk;
    return S_OK;
  }
  
  STDMETHODIMP ReleaseMarshalData(...) {
    ULONG actual;
    DWORD mshlflags;
    RETURN_IF_FAILED(pstm->Read(&mshlflags, sizeof(mshlflags)), &actual);
    RETURN_HR_IF(E_FAIL, actual != sizeof(mshlflags));
    IUnknown* punk;
    RETURN_IF_FAILED(pstm->Write(&punk, sizeof(punk), &actual));
    RETURN_HR_IF(E_FAIL, actual != sizeof(*ppv));
    if (mshlflags != MSHLFLAGS_TABLEWEAK) punk->Release();
    return S_OK;
  }
};
%%


/// c++: ispanstream, c++23 strstream replacement
# https://github.com/QuantlabFinancial/cpp_tip_of_the_week/blob/master/284.md

#include <span>
#include <spanstream>
#include <iostream>

int main() {
  char input[] = "1 2 3";
  std::ispanstream is{std::span<char>{input}};
  int i1, i2, i3;
  is >> i1 >> i2 >> i3;
  std::cout << i1 << i2 << i3; // prints 123
}
%%


/// c++: forcing to use make_unique/make_shared to construct an object
# https://devblogs.microsoft.com/oldnewthing/20220721-00/?p=106879

class Widget : public std::enable_shared_from_this<Widget> {
  private:
    struct Secret {
      explicit Secret() = default;               // explicit to forbid {} contruction trick
    };
    
  public:
    template<typename... Args> static auto Create(Args&&... args) {
      return std::make_shared<Widget>(Secret{}, std::forward<Args>(args)...);
    }
    
    Widget(Secret);                              // unusable from outside the class
    Widget(Secret, int);
    Widget(Secret, int, int);
    Widget(Widget const&) = delete;
};


template<typename T> 
struct require_make_shared : public std::enable_shared_from_this<T> {
  protected:
    struct use_the_create_method {
      explicit use_the_create_method() = default;
    };
    
  public:
    template<typename... Args>
    static auto Create(Args&&... args) {
      static_assert(std::is_convertible_v<T*, require_make_shared*>, "Must derive publicly r_m_s");
      return std::make_shared<T>(use_the_create_method{}, std::forward<Args>(args)...);
    }
    
    require_make_shared(require_make_shared const&) = delete;
};

class Widget : require_make_shared<Widget> {
  public:
    auto create() { return require_make_shared::Create(); }
    Widget(use_the_create_method);
    Widget(use_the_create_method, int);
    Widget(use_the_create_method, int, int);
};
%%


/// data structure: balanced trees, B-trees, B+tree
# https://architecturenotes.co/things-you-should-know-about-databases/
# https://architecturenotes.co/content/images/size/w2400/2022/07/Databases-01-1.jpg
%%


/// c++: reference to array
# https://github.com/QuantlabFinancial/cpp_tip_of_the_week/blob/master/288.md

void foo4(int(&)[42]);
int a[42]{};
foo(a);
%%


/// event-driven architecture: message broker, kafka, topics, keys, compaction strategies, retention
# https://stackoverflow.blog/2022/07/21/event-driven-topic-design-using-kafka/

message broker manages a number of topics (a.k.a. logs or streams)
one service produces a topic, while other services consume from the topic
to reduce dependencies between services (to maximize coupling) we publish/consume between A/B to communicate

in Apache Kafka:
messages have keys/keywords
keys can be used in compaction strategies to delete all messages with those key except for the latest one
upsert topics refer to update if it does exists, insert if it doesn't
to signify deletion we need a meesage with a key but a null payload, so called tombstone
retention settings can be used e.g. to delete any message that's older than 7 days
any number of consumer groups can read from the same topic
you can structure your data, however a schema is recommended, e.g. Apache Avro, Google Protobuf
topics can be joined and enhanced, but of equal throughput
there are 3 usual situations: 
  * entity topics (current state), 
  * event topics (record of fact, choreography architecture — decentralized system knowns only its inputs), 
  * request-and-response topics (asynchronous APIs, multiple producers and single consumer, orchestration architecture — service explicitly tells other services what to do)
%%


/// c++23: deducing 'this'
# C++ weekly with Jason Turner, Ep 326 C++23's Deducing `this`, 2022-05-30
# https://www.youtube.com/watch?v=5EGw4_NKZlY

template<typename Contained, std::size_t Width, std::size_t Height>
struct Matrix {
    Contained& at(std::size_t X, std::size_t Y) {                    // non-const accessor
      return at(*this, X, Y);
    }

    const Contained& at(std::size_t X, std::size_t Y) const {        // const accessor
      return at(*this, X, Y);
    }
  
    std::array<Contained, Width * Height> data;
  
  private:
    template<typename This>
    static auto& at(This& obj, std::size_t X, std::size_t Y) {       // general accessor
      return obj.data.at(Y * Width + X);
    }
};
int main() {
  Matrix<int, 5, 5> data;
  data.at(2, 3) = 15;                                                // mutable
  return data.at(2, 3);                                              // immutable
}


template<typename Contained, std::size_t Width, std::size_t Height>
struct Matrix {
  template<typename Self>
  auto& at(this Self&& self, std::size_t X, std::size_t Y) {         // non-static function
    return std::forward<Self>(self).data.at(Y * Width + X);
  }
  
  std::array<Contained, Width * Height> data;
};
int main() {
  const Matrix<int, 5, 5> data{};
  return data.at(2, 3);
}
int main() {
  const Matrix<int, 5, 5> data{};
  using const_at = const int& (*)(const Matrix<int, 5, 5>&, std::size_t, std::size_t);
  auto func = Matrix<int, 5, 5>::at(const Matrix<int, 5, 5>&);
  return func(data, 2, 3);
}
%%


/// c++23: multidimensional subscript operator
# Cᐩᐩ Weekly With Jason Turner, "Ep 327 - C++23's Multidimensional Subscript Operator Support"
# https://www.youtube.com/watch?v=g4aNGgLzVqw

template<typename Contained, std::size_t Width, std::size_t Height>
struct Matrix {
  const auto& operator[](std::size_t X, std::size_t Y) const {
    return data[Y * Width + X]
  }
  
  std::array<Contained, Width * Height> data;
};

int main() {
  const Matrix<int, 5, 5> data{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
  return data[0,2];                                                            // 2*5+0 = 11
}
%%


/// c++23: recursive lambda
# Cᐩᐩ Weekly With Jason Turner, "C++ Weekly - Ep 328 - Recursive Lambdas in C++23"
# https://www.youtube.com/watch?v=hwD06FNXndI

int main() {
  // C++23's deducing this + C++20's explicit template parameter for lambda
  constexpr auto factorial = [](this const auto& self, int value) {
    if (value == 1) return value;
    else return value * self(value - 1);
  };
  
  // highly possibly unoptimized binary code
  return factorial(4);
}
%%


/// linker cmake: lto, ipo, inter-procedural optimization, link-time optimization
# Cᐩᐩ Weekly With Jason Turner, "C++ Weekly - Ep 329 - How LTO Easily Makes Your Program Faster"
# https://www.youtube.com/watch?v=9nzT1AFprYM

With LTO translation units (object files) are transposed into intermediate representations.
In practice this goes with aggressive optimization (faster compile times, probably slow link times).

# CMakeLists.txt
include(CheckIPOSupported)
set_property(TARGET test PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)
%%


/// c++: extern template
# Cᐩᐩ Weekly With Jason Turner, "C++ Weekly - Ep 330 - Faster Builds with `extern template` (And How It Relates to LTO)"
# https://www.youtube.com/watch?v=pyiKhRmvMF4

'I promise that somewhere there will be a version of this template that is already been created for you'
Extern template saves us on build time in each cpp file of our large project.
With extern template we may lose some compiler optimization, yet LTO/IPO may re-enable them again.


# declarations.hpp
extern template int add<int>(int, int);          // 'undefined reference' if not defined

# impl.cpp
#include "declarations.hpp"
template int add<int>(int, int);
%%


/// c++: lambda vs callable vs function pointer
# Cᐩᐩ Weekly With Jason Turner, "C++ Weekly - Ep 332 - C++ Lambda vs std::function vs Function Pointer"
# Cᐩᐩ Weekly With Jason Turner, "C++ Weekly - Ep 333 - A Simplified std::function Implementation"
# https://www.youtube.com/watch?v=aC-aAiS5Wuc
# https://www.youtube.com/watch?v=xJSKk_q25oQ

lambda — a C++ language construct for defining an anonymous function
std::function — a type-erased wrapper around a 'callable'
function object — an object that can be executable
functor — a theoretical non-structured executor; in C++ it's a synonim for a function object


int add(int x, int y) {                               // @call(int(*)(int,int)):    @call(...):
  return x + y;                                       // add  a5, zero, a0          addi sp, sp, -16
}                                                     // addi a1, zero, 3           sd   ra, 8(sp)
int call(int (*f)(int, int)) {                        // addi a0, zero, 2           addi a1, zero, 2
  return f(2, 3);                                     // jr   a5                    sw   a1, 4(sp)
}                                                     //                            addi a1, zero, 3
int call(const std::function<int(int, int)>& f) {     //                            sw   a1, 0(sp)
  return f(2, 3);                                     //                            ld   a1, 16(a0)
}                                                     //                            beqz a1, .LBB2_2
                                                      //                            ld   a3, 24(a0)
                                                      //                            addi a1, sp, 4
                                                      //                            add  a2, zero, sp
                                                      //                            jalr a3
                                                      //                            ld   ra, 8(sp)
                                                      //                            addi sp, sp, 16
                                                      //                            ret

int main() {
  int val = 15;
  std::vector<std::function<int(int,int)>> ops;
  ops.emplace_back([](int x, int y){ return x + y; });
  ops.emplace_back([](int x, int y){ return x * y; });
  ops.emplace_back([=](int x, int y){ return val + x - y; });        // ok
  
  std::vector<int(*)(int,int)> ops2;                                 // implicitly converted to...
  ops2.emplace_back([](int x, int y){ return x + y; });              // ...a stateless lambda
  ops2.emplace_back([](int x, int y){ return x * y; });
  ops2.emplace_back([=](int x, int y){ return val + x - y; });       // not ok, compile error
}


template<typename T>                                  // simplified std::function implementation
class function;

template<typename Ret, typename... Param>
class function<Ret(Param...)> {                       // partial specilization
  public:
    template<typename FuncObj>
    function(FuncObj fo) : callable(std::make_unique<callable_impl<FuncObj>>(std::move(fo))) {
    }
        
    Ret operator()(Param... param) {                  // to call callables we need to store them
      return callable->call(param...);                // we do not want to handle types (type-erasure)
    }
    
    // worry about forwarding and unwrapping of std::reference_wrapper
    // copy constructor
    
  private:
    struct callable_interface {                       // runtime- & compile-time polymorphism
      virtual Ret call(Param...) = 0;
      virtual ~callable_interface() = default;        // to handle UB
      // finish rule of 5
      // virtual clone()
    };
    
    template<typename Callable>
    struct callable_impl : callable_interface {
      callable_impl(Callable callable_) : callable{std::move(callable_)} {
      }
      Ret call(Param... param) {
        return std::invoke(callable, param...);
      }

      Callable callable;
    };
    
    std::unique_ptr<callable_interface> callable;
};
int main() {
  function<int(int,int)> func1{[](int x, int y){ return x + y; }};
  function<int(int,int)> func2{f};
  return func1(1, 2) + func2(3, 4);
}
%% 


/// c++: lambda in a container
# Cᐩᐩ Weekly With Jason Turner, "C++ Weekly - Ep 334 - How to Put a Lambda in a Container"
# https://www.youtube.com/watch?v=qmd_yxSOsAE

auto make_lambda(int value) {
  return [value](int i) { return i + value; }
}
int main() {
  
  std::vector<decltype(make_lambda(42))> data;
  data.push_back(make_lambda(1));
  data.push_back(make_lambda(2));
}


struct my_lambda {
  int value;
  int operator()(int i) { return i + value; }
};
auto make_lambda(int value) -> my_lambda {
  return my_lambda{value};
}
using lambda_vector = std::vector<my_lambda>;              // ODR !
auto make_lambda_vector() -> lambda_vector {
  lambda_vector vec;
  vec.push_back(make_lambda(1));
  vec.push_back(make_lambda(2));
  return vec;
}
int main() {
  auto data = make_lambda_vector();
  data.push_back(make_lambda(1));
  data.push_back(make_lambda(2));
}
%%


/// design: functions should do only one thing, extract till you drop
# https://sites.google.com/site/unclebobconsultingllc/one-thing-extract-till-you-drop
# https://www.sandordargo.com/blog/2022/07/27/cpp-on-sea-trip-report
%%


/// static analysis: code smell
# https://martinfowler.com/bliki/CodeSmell.html#:~:text=A%20code%20smell%20is%20a,me%20with%20my%20Refactoring%20book.
"A code smell is a surface indication that usually corresponds to a deeper problem in the system. The term was first coined by Kent Beck while helping me with my Refactoring book." — Martin Fowler
%%


/// design patterns: classification (architectural, design, idioms)
# http://modernescpp.com/index.php/classification-of-patterns-2
# https://www.modernescpp.com/images/blog/Patterns/ClassificationPatterns/posa_1.png

STRUCTURAL CATEGORY        ARCHITECTURAL PATTERNS                DESIGN PATTERNS             IDIOMS
scale & abstraction        structure & system                    interactions & subsystems   impl in PL

                                     [macro level] ----> [micro level] ----> [programming language]
    [abstract] ------------------------------------------------------------------------> [concrete]

from mud to structure      layers
                           pipes and filters
                           blackboard
distributed systems        broker
interactive systems        model-view-controller
                           presentation-abstraction-controller
adaptable systems          microkernel
                           reflection
structural decomposition                                          whole-part
organization of work                                              master-slave
access control                                                    proxy
management                                                        command processor
                                                                  view handler
communication                                                     forwarder-receiver
                                                                  client-dispatcher-server
                                                                  publish-subscriber
resource management                                                                          counted ptr
                                                                                             (RAII in C++)

Layers: split tasks into layers, with its own responsibilities, and interconnected
Pipes & Filters: decompose a complex task into a series of separate reusable elements
Blackboard: subsystems assemble together to build a possible partial non-deterministic solution
Broker: distributed system structure for remote service invocations (communication, results, exceptions)
Model-View-Controller: divides GUI logic into separate components (data & rules, data, user interaction)
Presentation-Abstraction-Controller: hierarchical structure of agents (each agent consists of P, A, & C)
Microkernel: separates a minimal function core from extended functionality
Reflection: a system as two parts (meta level and base level, properties and application logic)
Whole-Part: aggregate components to provide a common interface for the parts (e.g. Composite)
Master-Slave: master distributes the work and collects the results from slaves
Proxy: a wrapper for client to access the real object (may add its own logic: caching, encryption)
Command Processor: embodies commands into objects (to be scheduled, stored, e.g. Chain of Responsibility)
View Handler: all views that a software system provides (open, manipulate, dispose, update)
Forwarder-Receiver: transparent IPC for P2P interaction model (decouple peers from underlying mechanisms)
Client-Dispatcher-Server: transparency and common interface between client and server (e.g. Mediator)
Publish-Subscriber: publisher may automatically notify all subscribers (e.g. Observer)
Counted Pointer: a reference counter for dynamically-allocated shared objects (e.g. std::shared_ptr in C++)
%%


/// idiom: copy-and-swap as a transaction (without exceptions)
# https://www.sandordargo.com/blog/2022/08/10/copy-and-swap-idiom-in-cpp

'Strong exception safety, also known as commit or rollback semantics: Operations can fail, but failed operations are guaranteed to have no side effects, leaving the original values intact.'

class C {
  public:
    C(int x, int y) noexcept : m_x(x), m_y(std::make_unique<int>(y)) {}
    C(const C& other) noexcept : m_x(other.m_x), m_y(std::make_unique<int>(*other.m_y)) {}

    C(C&&) noexcept = default;
    C& operator=(C&& other) noexcept = default;
    
    ~C() noexcept = default;
  
    C& C::operator=(const C& other) noexcept {
      if (this != &other) {
        C temp(other);
        swap(*this, temp);
      }
      return *this;
    }
    
    friend void swap(C& lhs, C& rhs) noexcept {
      using std::swap;
      swap(lhs.m_x, rhs.m_x);
    }
    
  private:
    int m_x;
    std::unique_ptr<int> m_y;
};
%%


/// c++ design: type erasure vs strategy-based solution
# https://www.youtube.com/watch?v=4eeESJQk-mw
# CppCon, "Breaking Dependencies: Type Erasure - A Design Analysis - Klaus Iglberger - CppCon 2021"

# (1) a strategy-based solution
class Shape {
  public:
    Shape() = default;
    virtual ~Shape() = default;    
    virtual void draw() const = 0;
    virtual void serialize() const = 0;
};

class Circle;

class DrawCircleStrategy {
  public:
    virtual ~DrawCircleStrategy() {}
    virtual void draw(Circle const& circle) const = 0;
};

class Circle : public Shape {
  public:
    Circle(double rad, std::unique_ptr<DrawCircleStrategy> strategy) 
      : radius{rad}, drawing{std::move(strategy)}
    {}
    
    double radius() const noexcept;
    
    void draw() const override {
      drawing->draw(this);
    }
    
    void serialize() const override;
    
  private:
    double radius;
    std::unique_ptr<DrawStrategy> drawing;
};

class Square;

class DrawSquareStrategy {
  public:
    virtual ~DrawSquareStrategy() {}
    virtual void draw(Square const& square) const = 0;
};

class Square : public Shape {
  public:
    Square(double s, std::unique_ptr<DrawSquareStrategy> strategy)
      : side{s}, drawing{std::move(strategy)}
    {}
    
    double side() const noexcept;
    
    void draw() const override {
      drawing->draw(this);
    }
    
    void serialize() const override;
    
  private:
    double side;
    std::unique_ptr<DrawSquareStrategy> drawing;
};

class OpenGLCircleStrategy : public DrawSquareStrategy {
  public:
    virtual ~OpenGLCircleStrategy() {}
    void draw(Circle const& circle) const override;
};

class OpenGLSquareStrategy : public DrawSquareStrategy {
  public:
    virtual ~OpenGLSquareStrategy() {}
    void draw(Square const& square) const override;
};

int main() {
  using Shapes = std::vector<std::unique_ptr<Shape>>;

  Shapes shapes;
  shapes.emplace_back(std::make_unique<Circle>(2.0, std::make_unique<OpenGLCircleStrategy>()));
  shapes.emplace_back(std::make_unique<Square>(1.5, std::make_unique<OpenGLSquareStrategy>()));
  shapes.emplace_back(std::make_unique<Circle>(4.2, std::make_unique<OpenGLCircleStrategy>()));
  
  drawAllShapes(shapes);
}


# (2) a type-erased solution
class Circle {
  public:
    explicit Circle(double rad) : radius{rad} {}
    double radius() const noexcept;
    
  private:
    double radius;
};

class Square {                                        // Circles and Squares:
  public:                                             // • don't need a base class
    explicit Square(double s) : side{s} {}            // • don't know about each other
    double side() const noexcept;                     // • don't know anything about their ops
    
  private:
    double side;
};


class Shape {
  private:
    struct IShape {
      virtual ~IShape() = default;
      virtual void serialize() const = 0;
      virtual void draw() const = 0;
      virtual std::unique_ptr<IShape> clone() const = 0;
    };

    template<typename T>
    struct ShapeModel : IShape {                      // The External Polymorphism design pattern

      ShapeModel(T&& value) : object{std::forward<T>(value)} 
      {}
      
      std::unique_ptr<IShape> clone() const override {
        return std::make_unique<ShapeModel>(*this);   // the Prototype design pattern
      }

      void serialize() const override {
        serialize(object);                            // the implementation of the virtual
      }                                               // functions in the ShapeModel class
                                                      // defines the affordances (operations)
      void draw() const override {                    // required by the type T
        draw(object);
      }

      T object;
    };

    friend void serialize(Shape const& shape) {       // despite being defined inside the class
      shape.pimpl->serialize();                       // definition, these friend functions are 
    }                                                 // free functions and injected into the
                                                      // surrounding namespace
    friend void draw(Shape const& shape) {
      shape.pimpl->draw();
    }
  
    std::unique_ptr<IShape> pimpl;                    // the Bridge design pattern
    
  public:
    template<typename T>                              // a templated ctor, creating a bridge
    Shape(T const& x) : pimpl{new ShapeModel<T>(x)}   // type erasure
    {}

    Shape() = default;                                // some things to consider
    ~Shape() noexcept = default;
    
    Shape(Shape const& s) noexcept : pimpl{s.pimpl->clone()} {}
    
    Shape& operator=(Shape const& s) noexcept {
      if (*this != &s) pimpl = new ShapeModel<>(s);
      return *this;
    }
    
    Shape(Shape&& s) noexcept = default;
    Shape& operator=(Shape&& s) noexcept = default;
};

void serialize(Circle const&);                        // these functions resolve the requirements
void draw(Circle const&);                             // posed by the External Polymorphism pattern

void serialize(Square const&);                        // there can be many implementation, spread over
void draw(Square const&);                             // many header/source files, e.g. for Vulcan, Metal

void drawAllShapes(std::vector<Shape>> const& shapes) {
  for(auto const& shape : shapes) {
    shape->draw();
  }
}

int main() {
  using Shapes = std::vector<Shape>;
  
  Shapes shapes;
  shapes.emplace_back(Circle{2.0});
  shapes.emplace_back(Square{1.5});
  shapes.emplace_back(Circle{4.2});
  
  drawAllShapes(shapes);
}
%%


/// c++: deducing this
# https://www.youtube.com/watch?v=jXf--bazhJw
# CppCon, "Deducing this Patterns - Ben Deane - CppCon 2021"

struct S {
  std::string str;
  
  template<typename Self>
  auto get(this Self&& s) -> decltype(auto) {                        // getter for all
    return std::forward<Self>(s).str;
  }
  
  template<typename Self>
  auto get2(this Self&&) -> like_t<Self, std::string>&&;
};

int main() {
  auto value = someHeapThing();
  
  auto callback = [value = std::move(value)](this auto&& self, auto fn) {
    fn(forward_like<decltype(self)>(value));
  }
  
  // callback knows how to treat the captured object
  pass_to_async_op(callback);
}

void recursive_lambdas() {
  struct Leaf{};
  struct Node;
  using Tree = std::variant<Leaf, Node*>;
  struct Node { Tree left; Tree right; };
  template<typename... Fs> struct overloaded : Fs... { using Fs::operator()...; }
  
  int num_leaves(const Tree& tree) {
    return std::visit(overloaded{
      [](const Leaf&){ return 1; },
      [](this const auto& self, const Node* n) -> int {
        return std::visit(self, n->left) + std::visit(self, n->right);
      }
    }, tree)
  }
}

void ptr_to_member_function() {
  struct S {
    void f(int) const &;
    void g(this const S&, int);
  };
  
  S s;
  s.f(42);
  s.g(42);                             // OK with P0847
  
  auto pf = &S::f;                     // type: auto(S::*)(int) -> void
  (s.*pf)(42);
  std::invoke(pf, s, 42);

  auto pg = &S::g;                     // type: auto(*)(const S&, int) -> void
  pg(s, 42);                           // OK with P0847
  std::invoke(pg, s, 42);
}
%%


/// c++: const_cast example
# https://www.youtube.com/watch?v=2h2hdRqRIRk
# CppCon, "Back to Basics: Casting - Brian Ruth - CppCon 2021"

1/ removes/adds const/volatile qualifiers from/to a variable, cannot change type
2/ does not change the cv qualification of the original variable

int main() {
  int j = 4;
  const int* cj = &j;
  modify_pointer(const_cast<int*>(cj));                    // UB, cj is const-typed
}


struct my_array {
    char& operator[](std::size_t offset) {
      return const_cast<char&>(const_cast<const my_array&>(*this)[offset]);
      // recommended usage of const_cast
      // provided context is not used in a const manner (underlying type is non-const)
    }

    const char& operator[](std::size_t offset) const {
      return buffer[offset];
    }
  
  private:
    char buffer[10];
};

int main() {
  const my_array a;
  const auto& c = a[4];
  
  my_array mod_a;
  mod_a[4] = 7;
  
  return 0;
}
%%


/// c++: reinterpret_cast example
# CppCon | "Back to Basics: Casting - Brian Ruth - CppCon 2021" | https://www.youtube.com/watch?v=2h2hdRqRIRk

1/ can change any pointer/reference type to any other pointer/reference type
2/ also called type-punning
3/ cannot be used in a constexpr context
4/ can not remove cv qualification
5/ does not ensure sizes of To and From are the same
6/ useful for memory mapped functionality

int main() {
  volatile int& REGISTER = *reinterpret_cast<int*>(0x1234);
  // usuful for reinterpreting memory in embedded systems contexts...
  // ...or dealing with type aliasing and padding
}
%%


/// c++: named tuple
# CppCon | "++namedtuple - Python-style Named Tuples in C++20 - Kris Jusiak - CppCon 2021" | https://www.youtube.com/watch?v=4PwNi0Zgmm0

template<class... Ts>
using namedtuple = std::tuple<Ts...>;

template<auto Size>
struct fixed_string {
  char data[Size + 1]();
  static constexpr auto size = Size;
  
  constexpr explicit(false) fixed_string(char const* str) {
    std::copy_n(str, Size + 1, data);
  }
  
  constexpr explicit(false) operator std::string_view() const {
    return {data, Size};
  }
};

template<auto Size>
fixed_string(char const (&)[Size]) -> fixed_string<Size - 1>;

template<fixed_string Name, class TValue>
struct arg {
  static constexpr auto name = Name;
  TValue value{};
  
  template<class T>
  [[nodiscard]] constexpr auto operator=(const T& value) const {
    return arg<Name, T>{.value = value};
  }
};

template<fixed_string Name>
constexpr auto operator""_t() {
  return arg<Name, std::any>{};
}

template<fixed_string Name, class... Ts>
struct namedtuple : Ts... {
  constexpr explicit(true) namedtuple(Ts... ts) : Ts{ts}... {}
  constexpr auto& operator[](const auto&);
  constexpr const auto& operator[](const auto&) const;
  
  template<std::size_t, fixed_string> struct id_name {};
  
  template<std::size_t N, fixed_string Name>
  constexpr decltype(auto) get(id_name<N, Name>&&) {
    return get<Name>(*this);
  }
  
  template<std::size_t N> decltype(auto) get() {
    return get<N>([]<auto... Is>(std::index_sequence<Is...>) {
      return namedtuple{id_name<Is, Ts::name>{}...};
    }(std::make_index_sequence<sizeof...(Ts)>{}));              // IILE
  }
  
  template<class T>
  [[nodiscard]] constexpr auto operator[](T) -> decltype(get<T::name>(*this)) {
    return get<T::name>(*this);  // SFINAE friendly
  }
  
  friend std::ostream& operator<<(std::ostream& os, const namedtuple& nt) {
    os << Name << '(';
    
    std::apply([&](const auto&... args) {
      ((os << args.name << ':' << args.value), ...);
    }, nt);
    
    os << ')';
    return os;
  }
};

template<class... Ts>
namedtuple(Ts...) -> namedtuple<Ts...>;

namespace std {  // structured bindings
  template<class... Ts>
  struct tuple_size<namedtuple<Ts...>> : std::integral_constant<std::size_t, sizeof...(Ts)> {
  };
  
  template<std::size_t N, class... Ts>
  struct tuple_element<N, namedtuple<Ts...>> {   // doesn't work for packed tuples (composition)
    using type = decltype(std::declval<namedtuple<Ts...>>().template get<N>());
  };
}

int main() {
  constexpr auto nt1 = namedtuple("z"_t = 1'000);
  constexpr auto nt2 = namedtuple("x"_t = 42, "y"_t = 100, nt1);
  
  static_assert(not [](auto t) {
    return requires{ t["x"_t]; }
  }(nt1));
  
  constexpr auto [x, y] = namedtuple("x"_t = 4, "y"_t = 2);
  
  constexpr auto nt = namedtuple<"Point">("x"_t = 4, "y"_t = 2);
  std::cout << nt;
  // Point{x:4,y:2}
}
%%


/// c++: multiple destructors
# Sandor Dargo's Blog | "Multiple destructors with C++ concepts" | https://www.sandordargo.com/blog/2021/06/16/multiple-destructors-with-cpp-concepts
# Cᐩᐩ Weekly With Jason Turner | "C++ Weekly - Ep 231 - Multiple Destructors in C++20?! How and Why" | https://www.youtube.com/watch?v=A3_xrqr5Kdw

struct trivial {
  constexpr ~trivial() noexcept = default;
};

struct non_trivial {
  constexpr ~non_trivial() noexcept {
    std::cout << "non_trivial";
  }
};

int main() {
  WrapperOld<int> wint;                   // before C++20
  WrapperOld<std::string> wstr;
}


template<typename T>
class WrapperOld : public std::conditional_t<std::is_trivially_destructible_v<T>, trivial, non_trivial> {
  T t;
};

template<typename T>
class WrapperNew {
    T t;
    
  public:
    ~WrapperNew() noexcept requires(!std::is_trivially_destructible_v<T>) {
      std::cout << "~WrapperNew()";
    }
    
    ~WrapperNew() = default;
};

int main() {    
  WrapperNew<int> wint2;                  // from C++20
  WrapperNew<std::string> wstr2;
}
%%


/// hardware: hard drives and harmonic waves from songs
# Niebezpiecznik | "Słuchanie Janet Jackson może zaszkodzić Twoim danym" | https://niebezpiecznik.pl/post/sluchanie-janet-jackson-moze-zaszkodzic-twoim-danym/
# The Old New Thing | "Janet Jackson had the power to crash laptop computers" | https://devblogs.microsoft.com/oldnewthing/20220816-00/?p=106994
# The Old New Thing | "Janet Jackson had the power to crash laptop computers, follow-up" | https://devblogs.microsoft.com/oldnewthing/20220920-00/?p=107201
%%


/// computer science: canonicalisation, canonical form, canonical representation
# StackOverflow | "What does the term canonical form or canonical representation in Java mean?" | https://stackoverflow.com/questions/280107/what-does-the-term-canonical-form-or-canonical-representation-in-java-mean
# StackOverflow | "What does Canonical Representation mean and its potential vulnerability to websites" | https://stackoverflow.com/questions/1167371/what-does-canonical-representation-mean-and-its-potential-vulnerability-to-websi
# Wikipedia | "Canonicalization" | https://en.wikipedia.org/wiki/Canonicalization
# JavaTPoint | "Canonical Forms" | https://www.javatpoint.com/discrete-mathematics-canonical-forms

Canonical representation: a standard form of representation for data, e.g. in XML schema lexical representation of a boolean can be of {true, false, 1, 0}, whereas the canonical representation can be only of {true, false}; while dealing with different coordinates (cartesian, spherical, cylindrical) choosing one as the internal representation.

It is done to:
* compare different representation for equivalence, e.g. Unicode code points
* to improve efficiency of algorithms by eliminating repeated calculations, e.g. disjunctive normal form
* to impose a meaningful sorting order, e.g. lexicographical order

Canonized: reduced to the simplest and most significant form without losing generality.
Canonical form: values can be represented in multiple ways and one of those is chosen as the favored one, e.g. file paths as full paths (opposing to relative paths, symlinks paths).
Canonical instance: we chose one instance of a class of instances with the same content as the canonical reference, e.g. using reference identity == instead of object equivalence equals() in Java (which save space and possibly time as well).
%%


/// testing: tlp, ternary logic partitioning, metamorphic testing
# Strange Loop Conference | "Manuel Rigger: How to test software without writing tests" | https://www.youtube.com/watch?v=tLKTILnVasg

test oracle: is a mechanism for determining whether a test has passed or failed

TLP (Ternary Logic Partitioning): sylogism, ternary logic
consider a predicate P and a given row R, then exactly ONE of the following must hold: 
* P                     p = are_the_same(a=0.0, b=-0.0) = select * from a,b where a=b
* not P                 not_p = select * from a,b where not (a=b)
* P is NULL             is_p_null = select * from a,b where a=b is null
                        if (p union all not_p union all is_p_null) is empty then (a != b)

metamorphic testing:
test case               select * from a,b
result                  set (a, b), executed for a test case
derived test case       union{ p, not_p, p_null }
%%


/// c++: composability, composition instead of inheritance, how to write a composable hierarchy?
# CppCon | "Composable C++: Principles and Patterns - Ben Deane - CppCon 2021" | https://www.youtube.com/watch?v=zclxRbh4AN0

* zero object or default state (behaviour is more important than indentity)
* passthrough object (delegate self -> object, prefer right fold for lazy initialization)
* composable data structures (Visitor: OOP -> FP)

* match return types with arguments types (teoretically you only need bool and int)
* use: types, functions, objects, structures, computation (map/reduce, filter)
* recursive algorithms or abstraction over composable types
* coupled actions and state or SOLID principles
* no world-switching or shim layer (container -> container), Chain of Responsibility instead
* FP (functional programming) and Composite (heterogenous structures)
* separate what from where, and possibly from when
%%


/// design: design patterns in relation to algorithms and frameworks
# Modernes C++ | "About Algorithms, Frameworks, and Pattern Relations" | http://modernescpp.com/index.php/about-pattern-relations-algorithms-frameworks

"Patterns are not islands. (...) Patterns don't live in isolation, they are in relation to each other." — Rainer Grimm

Design Pattern: "Each pattern is a three part rule, which expresses a relation between a certain context, a problem, and a solution." — Christopher Alexander
anti-pattern is a proven way to shoot yourself into your foot — Andrew Koenig

Design pattern and...
* algorithms: general solution vs specific solution
* frameworks: more abstract & less specialized vs reused directly & have an application domain context
* patterns: relations (complements, compounds, sequences, collections, languages)

a framework is based on the Hollywood Principle ("Don't call us, we call you"). The Hollywood Principe means that the control flow is dictated by the framework but not by the caller when he would use a library. The framework provides a minimal application that can only be extended by the user by overriding specific methods

Pattern relations:
* complements (Strategy & Template Method as composition vs polymorphism, Mediator & Observer)
* compounds (MVC as Observer of changes + Composite of subviews + Strategy of user input)
* sequences (Iterator, Visitor, Composite)
* collections (organized by: intent, domain, level[architectural, design, idiom])
* languages (a set of patterns for a specific domain, e.g. concurrency, database access)
%%


/// design: event sourcing
# Martin Fowler | "Event Sourcing" | https://martinfowler.com/eaaDev/EventSourcing.html

Event Sourcing ensures that all changes to application state are stored as a sequence of events. Not just can we query these events, we can also use the event log to reconstruct past states, and as a foundation to automatically adjust the state to cope with retroactive changes.
The fundamental idea of Event Sourcing is that of ensuring every change to the state of an application is captured in an event object, and that these event objects are themselves stored in the sequence they were applied for the same lifetime as the application state itself.
A common example of an application that uses Event Sourcing is a version control system. Such a system uses temporal queries quite often.

The key to Event Sourcing is that we guarantee that all changes to the domain objects are initiated by the event objects. This leads to a number of facilities that can be built on top of the event log:
* Complete Rebuild (re-running the events from the event log)
* Temporal Query (determine app state at any given point in time + timelines as branching)
* Event Replay (rollback incorrect changes by replay events backwards)

Usage examples:
* One obvious form of return is that it's easy to serialize the events to make an Audit Log.Such an audit trail is useful for audit, no shocks there, but also has other usages.
* Another use for this kind of complete Audit Log is to help with debugging.
* Event Sourcing also raises some possibilities for your overall architecture, particularly if you are looking for something that is very scalable. There is a fair amount of interest in 'event-driven architecture' these days.
* An example of this would be a system with lots of readers and a few writers. Using Event Sourcing this could be delivered as a cluster of systems with in-memory databases, kept up to date with each other through a stream of events.


class EventProcessor {                                     // (1) Example of tracking ships
  public void process(DomainEvent e) {
    e.process();
    log.add(e);
  }
}

class DomainEvent {                                        // scheme for events
  internal DomainEvent(DateTime timestamp) {
    this.occured = timestamp;
    this.recorded = DateTime.Now;
  }
}

class DepartureEvent : DomainEvent {
  internal DepartureEvent(DateTime time, Port port, Ship ship) : base(time) {
    this.port = port;
    this.ship = ship;
  }
  internal override void process() {
    ship.handleDeparture(this);
  }
}

class ArrivalEvent : DomainEvent {
  internal ArrivalEvent(DateTime timestamp, Port port, Ship ship) : base(timestamp) {
    this.port = port;
    this.ship = ship;
  }
  internal override void process() {
    ship.handleArrival(this);
  }
}

class Ship : DepartureEvent, ArrivalEvent {
  public void handleDeparture(DepartureEvent e) {
    this.port = Port.AT_SEA;
  }
  public void handleArrival(ArrivalEvent ev) {
    Port = ev.Port;
    foreach (Cargo c in this.cargo) c.handleArrival(ev);
  }
}

class Cargo : ArrivalEvent {
  public void handleArrival(ArrivalEvent ev) {
    if (Country.CANADA == ev.Port.Country) this.hasBeenInCanada = true;
  }
}

class Tester {
  [Test] public void visitingCanadaMarksCargo() {
    var ev_proc = new EventProcessor();
    var cargo = new Cargo();
    var kr = new Ship("King Roy");

    ev_proc.process(new LoadEvent(new DateTime(2005,11,1), cargo, kr));
    ev_proc.process(new ArrivalEvent(...)...);
    ev_proc.process(new DepartureEvent(...)...);
    ev_proc.process(new UnloadEvent(...)...);

    assert.IsTrue(cargo.hasBeenInCanada);
  }
}

class Port {                                               // (2) updating an external system
  public void handleArrival(ArrivalEvent ev) {
    ev.ship.port = this;
    Registry.CustomsNotificationGateway.Notify(ev.occurred, ev.ship, ev.port);
  }
}

class CustomsEventGateway {
  public void notify(DateTime arrival, Ship ship, Port port) {
    if (this.processor.isActive) 
      SendToCustoms(BuildArrivalMessage(arrivalDate, ship, port));
  }
}

class EventProcessor {
  public void process(DomainEvent e) {
    this.isActive = true;
    e.process();
    this.isActive = false;
    log.add(e);
  }
}

class LoadEvent {                                          // (3) reversing an event
  internal LoadEvent(DateTime occurred, string cargo, int ship) : base(timestamp) {
    this.ship_code = ship;
    this.cargo_code = cargo;
  }
  internal override void process() {
    this.cargo.handleLoad(this);
  }
  internal override void reverse() {
    this.cargo.reverseLoad(this);
  }
}

class Cargo {
  internal void handleLoad(LoadEvent ev) {
    ev.prior_port = this.port;
    this.port = null;
    this.ship = ev.ship;
    this.ship.handleLoad(ev);
  }
  public void reverseLoad(LoadEvent e) {
    this.ship.reverseLoad(ev);
    this.ship = null;
    this.port = ev.prior_port;
  }
  public void handleArrival(ArrivalEvent ev) {
    ev.prior_cargo_in_canada[this] = this.has_been_in_canada;        // IDictionary
    if ("CA" == ev.port.country) this.has_been_in_canada = true;
  }
  public void reverseArrival(ArrivalEvent ev) {
    this.has_been_in_canada = (bool) ev.prior_cargo_in_canada[this];
  }
}
%%


/// term: anti-pattern
# Modernes C++ | "Anti-Patterns" | http://modernescpp.com/index.php/anti-patterns

"commonly-used process, structure or pattern of action that, despite initially appearing to be an appropriate and effective response to a problem, has more bad consequences than good ones" — Design Patterns: Elements of Reusable Object-Oriented Software (1994)
"specific repeated practices in software architecture, software design and software project management that initially appear to be beneficial, but ultimately result in bad consequences that outweigh hoped-for advantages" — AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis (1998)

software development:
* cut-and-paste programming (copy-and-paste)
* lava flow (dead code)
* onion — new code is wrapped around the old one
* swiss army knife (kitchen sink) — The One-Tool Wonder is a universal solution to all needs
* golden hammer (head-in-the-sand) — a familiar technology or concept applied obsessively

software architecture:
* the god class (the blob) — an object controlling to much, becoming The Class That Does Everything
* spaghetti code — unstructured and difficult-to-maintain code
* big ball of mud — a software system that lacks a perceivable architecture

project management:
* Brook's law ("adding manpower to a late software project makes it later") — new people slow down the development process because they have to be trained by experienced developers
* death march — a project that participants believe is destined for failure; culture based on control
* mushroom management ("Keep them in the dark and feed them full of shit") — a policy to keep system developers isolated from the system’s end users
%%


/// c++: constexpr with static/inline
# Cᐩᐩ Weekly With Jason Turner | "C++ Weekly - Ep 339 - `static constexpr` vs `inline constexpr`" | https://www.youtube.com/watch?v=QVHwOOrSh3w

static constexpr for constexpr values at function scope
inline constexpr for constexpr values at file scope
%%


/// term: type punning
treating one memory type as other memory type: reinterpret_casts
see: "Quake 4 Fast Inverse Square Root"
%%


/// term: leaf function
# The Old New Thing | "The x86-64 processor (aka amd64, x64): Whirlwind tour" | https://devblogs.microsoft.com/oldnewthing/20220831-00/?p=107077

a function that can do its work using only registers, including its whole stack (arguments)

A lightweight leaf function is one which can perform all of its work using only non-preserved registers, the inbound parameter home space, and stack space occupied by stack-based inbound parameters (if any). Preserved registers and the stack pointer must remain unchanged for the entire lifetime of the function, and the return address must remain at the top of the stack.
The x86-64 ABI abandons the stack-based exception handling model of its 32-bit older brother and joins the RISC crowd by using table-based exception handling. With the exception of lightweight leaf functions, all functions must declare unwind codes that allow the exception unwinder to restore registers from the stack and find the return address. Any function that does not have unwind codes is assumed to be a lightweight leaf function.
%%


/// design pattern: factory method, virtual constructor, slicing
# Modernes C++ | "The Factory Method" | http://modernescpp.com/index.php/factory-method
# Modernes C++ | "The Factory Method (Slicing and Ownership Semantics)" | http://modernescpp.com/index.php/factory-method-2
# C++ Core Guidelines | "C.67: A polymorphic class should suppress public copy/move" | https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c67-a-polymorphic-class-should-suppress-public-copymove


enum class WindowType {                               // (1)
  Default,                                            // usual implementation of Factory Method
  Fancy                                               // involves switch statement
};

class IWindow {
  public:
    virtual ~IWindow() noexcept = default;            // remember about the Rule of 5
    virtual WindowType type() const noexcept = 0;
};

class DefaultWindow : public IWindow {                // the same goes for FancyWindow
  public:
    WindowType type() const noexcept override {       // name() := "DefaultWindow"
      return WindowType::Default;
    }
};

std::unique_ptr<IWindow> getWindow(WindowType type) {
  // consider refactoring rule: Replace Conditional with Polymorphism
  switch (type) {
           case WindowType::Default: return std::make_unique<DefaultWindow>();
    break; case WindowType::Fancy:   return std::make_unique<FancyWindow>();
    break; default:                  return nullptr;
  }
}

int main() {
  auto wDefault = getWindow(WindowType::Default);
  auto wFancy = getWindow(WindowType::Fancy);
  std::cout << wDefault.name() << '\n';               // DefaultWindow
  std::cout << wFancy.name() << '\n';                 // FancyWindow

  // equivalent to:  
  std::array<IWindow,2> windows = { DefaultWindow{}, FancyWindow{} };
  std::ranges::for_each(windows, [](const auto& w){ std::cout << w.name() << '\n'; });
}



struct IWindow {                                           // (2)
    virtual IWindow create() const noexcept = 0;           // virtual dispatch used to
    virtual IWindow clone() const noexcept = 0;            // eliminate switch statement
    virtual ~IWindow() noexcept = default;
};

struct FancyWindow : public IWindow {                      // Concrete Product
    IWindow create() const noexcept override {
      return FancyWindow();
    }
    IWindow clone() const noexcept override {              // Prototype pattern
      return FancyWindow(*this);                           // copy ctor
    }
};

struct WindowCreator {                                     // Concrete Creator
    static IWindow create(const IWindow& w) noexcept {     // Client
      return w.create();
    }
    static IWindow clone(const IWindow& w) noexcept {      // consider: Builder pattern
      return w.clone();                                    // note: covariant return type
    }
};

int main() {
  DefaultWindow wDefault{};                                          // issues:
  FancyWindow wFancy{};                                              // ownership semantic
                                                                     // slicing, copy elision
  std::array<IWindow, 4> windows = {
    WindowCreator::create(wDefault), WindowCreator::create(wFancy),
    WindowCreator::clone(wDefault), WindowCreator::clone(wFancy)
  };
  
  std::ranges::for_each(windows, [](const auto& window) {            // unified access
    std::cout << window.name() << '\n';
  });
}


Slicing means you want to copy an object during assignment or initialization, and you get only a part of the object.
C++ Core Guidelines C.67: A polymorphic class should suppress public copy/move.

struct Base {
  virtual std::unique_ptr<Base> clone() const { return std::make_unique<>(*this); }
  virtual ~Base() noexcept = default;
};

struct Derived : private Base {
  virtual std::unique_ptr<Base> clone() const override { return std::make_unique<>(*this); }
};

auto clone_by_value(Base rhs) { return rhs.clone(); }
auto clone_by_ref(const Base& rhs) { return rhs.clone(); } 

int main() {
  Derived d;
  Base b1 = clone_by_value(d);       // will slice
  Base b2 = clone_by_ref(d);         // will not slice, std::unique_ptr cannot be copied
  Base b3(d);                        // will use copy ctor, copy/move should be suppressed or protected
  Base b4 = d;                       // will use copy assignment operator
}


# see also:
# (3) extended Factory pattern -> CppCon | "The Factory Pattern - Mike Shah - CppCon 2021" | https://www.youtube.com/watch?v=4xrNtB60g0g
# (4) Factory that remembers parameters passed -> The Old New Thing (Raymond Chen) | "Trying to create a factory that remembers the parameters to pass to another method" | https://devblogs.microsoft.com/oldnewthing/20220422-00/?p=106516
%%


/// c++: string split
# Cᐩᐩ Weekly With Jason Turner | "C++ Weekly - Ep 340 - Finally! A Simple String Split in C++!" | https://www.youtube.com/watch?v=V14xGZAyVKI

int main() {
  // lazy evaluation
  auto split = std::string_view{"Hello World C++20!"} | std::ranges::views::split(' ');
  
  for (const auto& str : split) {
    std::cout << std::string_view{str};
    fmt::print("{}\n", str);
  }
}

int main() {
  // range of ranges
  constexpr static auto split = std::string_view{"Hello World C++20!"} | std::ranges::views::split(' ');

  for (const auto& str : auto{split}) {
    fmt::print("{}\n", str);
  }
}
%%


/// c++: multiple conditional inheritance
# StackOverflow | "how can I achieve multiple conditional inheritance?" | https://stackoverflow.com/questions/73557662/how-can-i-achieve-multiple-conditional-inheritance

struct A { void a() {} };
struct B { void b() {} };
struct C { void c() {} };
struct D { void d() {} };

constexpr std::uint8_t FLAG_BIT_A = 0b1 << 0;
constexpr std::uint8_t FLAG_BIT_B = 0b1 << 1;
constexpr std::uint8_t FLAG_BIT_C = 0b1 << 2;
constexpr std::uint8_t FLAG_BIT_D = 0b1 << 3;

template<std::integral auto, class...>
struct inherit_mask {
};

template<auto flags, class Base, class... Derived>
requires((flags & 1) == 1)
struct inherit_mask<flags, Base, Derived...> : Base, inherit_mask<(flags >> 1), Derived...> {
};

template<auto flags, class Base, class... Derived>
struct inherit_mask<flags, Base, Derived...> : inherit_mask<(flags >> 1), Derived...> {
};

template<std::uint8_t flags>
using build = inherit_mask<flags, A, B, C, D>;

void test() {
  using foo = build<0b0101>;
  static_assert(std::derived_from<foo, A>);
  static_assert(std::derived_from<foo, C>);
  static_assert(not std::derived_from<foo, B>);
  static_assert(not std::derived_from<foo, D>);
  foo.a();
  foo.c();
}


template<class, template<class...> class B>
struct rename_impl {};

template<template<class...> class A, class... T, template<class...> class B>
struct rename_impl<A<T...>, B> {
  using type = B<T...>;
};

template<typename... types>
struct build_impl : types... {};

template<std::uint8_t flags, typename... types>
constexpr auto flags_to_tuple() {
  using flag_tuple = std::tuple<types...>;
  constexpr auto setBits = std::popcount(flags);
  
  constexpr auto flags_to_array = [&]() {
    std::array<unsigned, setBits> result{};
    unsigned ctr = 0u;
    
    for (unsigned i=0u; i<sizeof(flags)*8; ++i) {
      if (flags & (1 << i)) {
        result[ctr] = i;
        ++ctr;
      }
    }
    
    return result;
  };
  
  constexpr auto bit_array = flags_to_array();
  
  auto make_build = [&]<typename I, I... indices>(std::index_sequence<indices...>) {
    return std::tuple<std::tuple_element_t<bit_array[indices], flag_tuple>...>{};
  };
  
  return make_build(std::make_index_sequence<setBits>());
}

template<std::uint8_t flags>
using flags_tuple_type = decltype(flags_to_tuple<flags, A, B, C, D>);

template<std::uint8_t flags>
using build = typename rename_impl<flags_tuple_type<flags>, build_impl>::type;

int main() {
  build<FLAG_BIT_A | FLAG_BIT_C> foo;
  foo.a();
  foo.c();
}
%%


/// c++: coroutines
# Working Draft, Standard for Programming Language C++ | "Coroutine definitions" | https://eel.is/c++draft/dcl.fct.def.coroutine#def:coroutine
# C++ Tip of The Week | "Did you know that C++20 introduced coroutines?" | https://github.com/QuantlabFinancial/cpp_tip_of_the_week/blob/master/tips/296.md

#include <iostream>
#include <coroutine>

struct generator {
  struct promise_type;
  using handle = std::coroutine_handle<promise_type>;
  
  struct promise_type {
    int current_value;
    static auto get_return_object_on_allocation_failure() { return generator{nullptr}; }
    auto get_return_object()                              { return generator{handle::from_promise(*this)}; }
    auto initial_suspend()                                { return std::suspend_always{}; }
    auto final_suspend() noexcept                         { return std::suspend_always{}; }
    void unhandled_exception()                            { std::terminate(); }
    void return_void()                                    {}
    auto yield_value(int value)                           { current_value = value; return std::suspend_always{}; }
  };
  
  bool move_next()                            { return coro ? (coro.resume(), !coro.done()) : false; }
  int current_value()                         { return coro.promise().current_value(); }
  generator(generator const&)                 = delete;
  generator(generator&& rhs) : coro(rhs.coro) { rhs.coro = nullptr; }
  ~generator()                                { if (coro) coro.destroy(); }
  
  private:
  generator(handle h) : coro(h)               {}
  handle coro;
};

generator f() {
  for (auto i=0; i!=3; ++i) co_yield i;          // co_yield 0; co_yield 1; co_yield 2;
}

int main() {
  auto g = f();
  
  while (g.move_next())
    std::cout << g.current_value() << std::endl;
}
%%


/// design pattern: singleton
# Modernes C++ | "The Singleton" | http://modernescpp.com/index.php/creational-patterns-singleton
# Modernes C++ | "The Singleton: Pros and Cons" | http://modernescpp.com/index.php/singleton-pros-and-cons

Singletons: 
* are statics and global variables in disguise
* are potentially good for shared resource existing only in atomic manner, e.g. loggers


class Singleton {                                               // (1) classical implementation
  private:
    inline static std::shared_ptr<Singleton> instance{nullptr}; // C++17
    Singleton() = default;
    ~Singleton() noexcept = default;
    
  public:
    Singleton(const Singleton& rhs) = delete;                   // no copy
    Singleton& operator=(const Singleton& rhs) = delete;
    
    static Singleton& getInstance() {
      if (!instance) instance = std::make_shared<Singleton>(new Singleton);
      return instance.get();
    }
};

Flaws of (1): static initialization order fiasco and concurrency.
Static variables in one translation unit are initialized according to their definition order.
Between different TUs, however, if one static relies on second static than it fails.
The program is ill-formed because you have no guarantee which static variable is initialized first at run time.
When a static cannot be const-initialized during compile time, it is zero-initialized. 
At run time, the dynamic initialization happens for these statics that were zero-initialized.

int static_a = 25;                     // source_1.cpp

extern int static_a;                   // source_2.cpp
auto static_b = static_a;              // extern forces different TU

int main() {
  std::cout << static_b << '\n';       // 50 % chance to be either 0 or 25
}


class Singleton {                                          // (2) Scott Meyers' lazy implementation
  private:                                                 // the easiest and fastest way
    Singleton() = default;
    ~Singleton() noexcept = default;
  
  public:
    Singleton(const Singleton& rhs) = delete;
    Singleton& operator=(const Singleton& rhs) = delete;
    
    static Singleton& instance() {
      static std::shared_ptr<Singleton> instance{new Singleton};
      return instance;
    }
};

int main() {
  auto future = std::async(std::launch::async, []() {
    auto start = std::chrono::system_clock::now();
    auto inst = Singleton::instance();
    auto end = std::chrono::system_clock::now();
    std::cout << &inst << '\n';
    return end - begin;
  });
  
  std::cout << future.get().count();
}

Cons of (2): can not take part in static initialization order fiasco; since C++11 static variables with local scope are also initialized in a thread-safe way.


Singleton features:
* Global Access Point (globals, but protected)
* Unique Entity Model (easy to reason about abstraction, e.g. timers, factories, unique IDs, registration offices)
* Static Initialization Order Fiasco (overcomed by Meyers' lazy implementation)
* concurrency issues (overcomed by Meyers' lazy implementation since C++11)
* too often used (every misused pattern is bad)
* hidden dependency (breaks testability, but it may be used as a parameter and mocked)

void func() {
  DAO::instance().update("insert into features(unit-testable, reason) values(no, hidden-dependency);");
}
void func(DAO& db = DatabaseAccessObjectMock::instance()) {
  db.update("insert into features(unit-testable, reason) values(yes, dependency-injection);");
}


# see also:
# Meyers' lazy/synchronized initialization for Java
# using std::call_once to register a callable which will be executed exactly once
# applying sequential consistency to data (std::atomic + std::mutex with std::lock_guard)
%%


/// c++: ranges
# Cᐩᐩ Weekly With Jason Turner | "C++ Weekly - Ep 342 - C++20's Ranges: A Quick Start" | https://www.youtube.com/watch?v=sZy9XcGHmI4
# P2214R2 | "A Plan for C++23 Ranges" | https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2214r2.html

#include <algorithm>
#include <ranges>
#include <vector>

std::vector<int> data() {
  return std::vector<>{2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13};
}

void test_data() { // two temporaries, -D_GLIBCXX_DEBUG
  auto result = std::all_of(data().begin(), data().end(), [](const int i){ return i<5; })
}

void test_data() { // just <algorithm>
  auto data = data();
  auto result = std::all_of(data.begin(), data.end(), [](const int i){ return i<5; })
}

void test_data() { // <ranges>, handy adapters for common algorithms, all constexpr capable
  // all that are lower than 5: [2, 3, 4]
  auto result = std::ranges::all_of(data(), [](const int i){ return i<5; })
}

void test_data() { // pipeable range views
  // drop front 2, then take front 2: [4, 5], that are lower than 5: [4]
  auto result = std::ranges::all_of(data(), std::ranges::views::drop(2) | std::ranges::views::take(2), 
    [](const int i){ return i<5; }
  );
}

void iterate_data() { // simple solutions to annoying problems
  // drop first: [3, 4, 5, 6, 8, 9, 10, 11, 12, 13]
  // also see: std::ranges::views::drop_while(predicate), std::ranges::drop_view_while(predicate)
  for (const auto& i : data() | std::ranges::views::drop(1)) {
    fmt::print("{}\n", i);
  }
}

void iterate_with_index() { // lazy transform has interesting implications
  auto make_index = [idx=std::size_t{0}]<typename T>(const T& elem) mutable {
    return std::pair<std::size_t, const T&>{idx++, elem};
  };
  
  // ranges are lazy evaluated
  for (const auto& [index, elem] : data() | std::ranges::views::transform(make_index) | std::ranges::views::take(5)) {
    // take 5 after applying transform: [2, 3, 4, 5, 6]
    fmt::print("{}: {}\n", index, elem);
  }
}

auto split_string() {
  // split by a space: ["Hello", "World", "C++20!"]
  return split = std::string_view{"Hello World C++20!"} | std::ranges::views::split(' ');
}
%%


/// c++: std::promise, asynchronous computation vs concurrent execution
# StackOverflow | "What is std::promise?" | https://stackoverflow.com/questions/11004273/what-is-stdpromise
# Bartosz Milewski's Programming Cafe | "Broken promises–C++0x futures" | http://bartoszmilewski.com/2009/03/03/broken-promises-c0x-futures/

Multithreading/Remote code concepts in C++:
* asynchronous computation: a function that is called somewhere else, comes with a hierarchy of abstraction
* concurrent execution: something that does work concurrently, usually a thread

Hierarchy of asynchronous computation:
1* std::async (a task; straightforward template for an asynchronous task which returns future immediately)
2* std::thread, std::packaged_task (a processing node; asynchronous task implemented in a way that you may control)
3* std::promise (a result handle; a building block to communicate with a future)

int foo(double, char, bool);
auto fut = std::async(foo, 1.5, 'x', false);               // concurrent execution
auto res = fut.get();                                      // consider: std::launch::deferred

std::packaged_task<int(double, char, bool)> task(foo);     // std::async that we control
auto fut = task.get_future();                              // may be emulated using std::bind
std::thread thr(std::move(task), 1.5, 'x', false);         // join or detach eventually, when done future is ready

std::promise<int> p;                                       // channel (provider)
std::future<int> f = p.get_future();                       // synchronization mechanism (return object)
std::thread t(async_fun, std::move(p));                    // fetch (execute, then transfer via a channel)
int result = f.get();                                      // may throw

template<typename> class my_task;
template<typename R, typename... Args> class my_task<R(Args...)> {
  public:
    template<typename... Ts> explicit my_task(Ts&&... ts) : fn(std::forward<Ts>(ts)...) { }
    template<typename... Ts> void operator()(Ts&&... ts) { pr.set_value(fn(std::forward<Ts>(ts)...)); }
    std::future<R> get_future() { return pr.get_future(); } 
    // note: only 1 future value may be obtained!
    // to satisfy copy/move: suppress copy, allow for move
    // to satisfy promise state provide exceptions: std::future_error, std::broken_future
  private:
    std::function<R(Args...)> fn;
    std::promise<R> pr;
};
std::my_task<int(double, char, bool)> tsk(foo);            // asynchronous provider
auto fut = tsk.get_future();                               // asynchronous return object
%%


/// languages: string interpolation, variable interpolation, variable substitution, variable expansion
# Wikipedia | "String interpolation" | https://en.wikipedia.org/wiki/String_interpolation

apples = 4                                  # Python
print("I have ${apples} apples.")           # string interpolation
print("I have " + apples + " apples.")      # string concatenation
print("I have %s apples.", apples)          # format string
print(f'I have {apples} apples')            # formatted string literal

alternative to:
* concatenation
* string format functions, e.g. printf
* string literals (anonymous strings)

implementation algorithms:
* replace-and-expand-placeholders (new string by find-and-replace; no cache strategy)
* split-and-join-string (string to array, merge, concatenate; cache reuse is preferrable)
%%


/// concept standard: guid, uuid, globally unique identifier, universally unique identifier, rfc 4122
# The Old New Thing | "Why does COM express GUIDs in a mix of big-endian and little-endian? Why can’t it just pick a side and stick with it?" | https://devblogs.microsoft.com/oldnewthing/20220928-00/?p=107221
# RFC 4122 | "A Universally Unique IDentifier (UUID) URN Namespace" | https://datatracker.ietf.org/doc/html/rfc4122
# Wikipedia | "Universally unique identifier" | https://en.wikipedia.org/wiki/Universally_unique_identifier
# Wikipedia | "Globally Unique Identifier" | https://pl.wikipedia.org/wiki/Globally_Unique_Identifier
# Wikipedia | "Snowflake ID" | https://en.wikipedia.org/wiki/Snowflake_ID
# Recommendation ITU-T X.667 | "ITU-T X.667 (10/2012)" | https://www.itu.int/ITU-T/recommendations/rec.aspx?rec=11746&lang=en
# ISO/IEC 9834-8:2014 | "ISO/IEC 9834-8:2014 Information technology — Procedures for the operation of object identifier registration authorities — Part 8: Generation of universally unique identifiers (UUIDs) and their use in object identifiers" | https://www.iso.org/standard/62795.html
# ITU-T UUID Generator | "Universally Unique Identifiers (UUIDs)" | https://www.itu.int/en/ITU-T/asn1/Pages/UUID/uuids.aspx
# Class UUID | "java.util.UUID" | https://docs.oracle.com/javase/1.5.0/docs/api/java/util/UUID.html
# Boost UUID | "boost/uuid/uuid.hpp" | https://www.boost.org/doc/libs/1_65_0/libs/uuid/uuid.html
# Python UUID | "lib/uuid.py" | https://docs.python.org/3/library/uuid.html


* standardized way of aquiring a unique identifier
* represented in a hexadecimal format
* called snowflake IDs in context of a distributed computing (64-bits only; used by Twitter, Discord, Instagram)
* versions/variants are available (Nil; v1: date, time, MAC address; v2: +DCE security version; v3/5: namespace name-based, hashed with MD5/SHA-1; v4: random)
* v1/v2 is unlikely to collide if there is no randomness; v3/5/4 collision probability is similar to the birthday problem (S-shaped curve); v4 50 % collision probability = n ~ 2.71*10^18 = 2.71 quintillions
* used in: file systems (ext4 userspace, LUKS encrypted partitions, macOS, Solaris Fault Management Event for crash dumps), COM (Windows' Component Object Model: IID, CLSID, LIBID, CATID), databases (unique keys: NEWID in MS SQL Server, timestamps in Laravel)

Examples:
urn:uuid:123e4567-e89b-12d3-a456-426655440000    # URN (Uniform Resource Name) namespace, RFC 4122
{123e4567-e89b-12d3-a456-426652340000}           # Microsoft GUID
8d7fb395-aa64-4888-a449-f92ef5c48c1d             # usual representation
12345678123456781234567812345678                 # raw form, without dashes


struct GUID {                // Windows implementation, always little-endian, v1
  uint32_t Data1;            // time_low
  uint16_t Data2;            // time_mid
  uint16_t Data3;            // time_hi_and_version
  uint8_t Data4[0];          // clock_seq_hi_and_reserved
  uint8_t Data4[1];          // clock_seq_low
  uint8_t Data4[2..7];       // node, 6-byte MAC address
};

class UUID:                  // Python implementation, v4
  time_low                   // 32-bits
  time_mid                   // 16-bits
  time_hi_version            // 16-bits
  clock_seq_hi_variant       // 8-bits
  clock_seq_low              // 8-bits
  node                       // 48-bits
  time                       // 64-bit timestamp
  clock_seq                  // 14-bit sequence number

version 1 & 2 UUID record layout:
  time_low                                  32 bits        4 B       low 32-bits of time
  time_mid                                  16 bits        2 B       middle 16-bits of time
  time_hi_and_version                       16 bits        2 B       4-bit of MSB, followed by high 12-bits of time
  clock_seq_hi_and_res_clock_seq_low        16 bits        2 B       1/3-bit of MSB, followed by 13/15-bits of clock
  node                                      48 bits        6 B       48-bit node id
%%



